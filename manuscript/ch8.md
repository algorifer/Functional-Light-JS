# Functional-Light JavaScript
# Глава 8: Рекурсия

Вам понравилось наше небольшое путешествие в мир замыканий и объектов в предыдущей главе? Добро пожаловать обратно!

На следующей странице мы перейдём к теме рекурсии.

<hr>

*(остальная часть страницы намеренно оставлена пустой)*

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

<div style="page-break-after: always;"></div>

Давайте поговорим о рекурсии. Прежде чем начать, обратитесь к предыдущей странице за формальным определением.

Слабая шутка, знаю. :)

Рекурсия — один из тех приёмов программирования, которые большинство разработчиков признают мощными, но не любят использовать. Я бы отнёс её к той же категории, что и регулярные выражения: инструмент для «особых случаев», который часто вызывает недоумение.

Я большой поклонник рекурсии — и вы тоже сможете ею стать! К сожалению, многие примеры рекурсии ограничиваются тривиальными академическими задачками вроде генерации чисел Фибоначчи. Если только вы не работаете в банке, где анализируют потоки денег с помощью Фибоначчи, вряд ли это будет для вас по-настоящему полезно.

На самом деле рекурсия — один из важнейших способов, с помощью которых FP-разработчики избегают императивных циклов и переназначения, перекладывая детали реализации на язык и движок. Когда вы правильно используете рекурсию, вы делаете свой код более декларативным и понятным.

К сожалению, рекурсии уделяют гораздо меньше внимания, чем стоило бы, особенно в JS, во многом из-за реальных ограничений по производительности (скорость и память). Наша цель в этой главе — глубже изучить рекурсию и её практическое применение.

## Определение

Рекурсия — это когда функция вызывает саму себя, и этот вызов снова вызывает себя, и цикл продолжается, пока не выполнится базовое условие, после чего цепочка вызовов разворачивается обратно.

**Внимание:** Если вы не обеспечите достижение базового условия, рекурсия будет выполняться бесконечно, и ваша программа зависнет или упадёт. Базовое условие критически важно!

Но... такое определение на письме может запутать. Давайте лучше посмотрим на пример:

```js
function foo(x) {
    if (x < 5) return x;
    return foo( x / 2 );
}
```

Давайте визуализируем вызов `foo(16)`:

<p align="center">
    <img src="images/fig13.png">
</p>

На шаге 2, `x / 2` даёт 8, и это значение передаётся в рекурсивный вызов `foo(..)`. На шаге 3 — снова делим на 2, получаем 4, и вызываем `foo(4)`. 

Но где часто путаются — это шаг 4. Когда базовое условие выполнено (`x` стало 4, то есть `< 5`), больше рекурсивных вызовов не происходит, и функция просто возвращает результат.

<p align="center">
    <img src="images/fig14.png">
</p>

Как только базовое условие выполнено, возвращаемое значение «каскадом» проскакивает через все предыдущие вызовы, в итоге возвращая итоговый результат наружу.

Можно посмотреть на рекурсию и как на последовательность вызовов в стеке (call stack):

<p align="center">
    <img src="images/fig19.png" width="30%">
</p>

О стеке вызовов — чуть ниже.

Вот ещё пример рекурсии:

```js
function isPrime(num, divisor = 2){
    if (num < 2 || (num > 2 && num % divisor == 0)) {
        return false;
    }
    if (divisor <= Math.sqrt(num)) {
        return isPrime(num, divisor + 1);
    }
    return true;
}
```

Проверка на простое число: перебираем делители от 2 до корня из числа, если делится — не простое, иначе — простое.

Один из самых известных примеров рекурсии — вычисление числа Фибоначчи:

```txt
fib(0): 0
fib(1): 1
fib(n): fib(n-2) + fib(n-1)
```

**Примечание:** Первые числа последовательности: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ... Каждое следующее — сумма двух предыдущих.

Код:

```js
function fib(n) {
    if (n <= 1) return n;
    return fib(n - 2) + fib(n - 1);
}
```

`fib(..)` вызывает себя дважды — это называют бинарной рекурсией. Об этом позже чуть подробнее.

В этом варианте работы много дублирующихся вычислений. Для оптимизации часто используют мемоизацию (см. [глава 5, «Побочные эффекты ради производительности»](ch5.md/#performance-effects)), чтобы каждое значение вычислялось только один раз.

### Взаимная рекурсия

Когда функция вызывает саму себя — это прямая рекурсия. Но бывают случаи, когда две или более функций вызывают друг друга — это взаимная рекурсия.

Пример:

```js
function isOdd(v) {
    if (v === 0) return false;
    return isEven(Math.abs(v) - 1);
}

function isEven(v) {
    if (v === 0) return true;
    return isOdd(Math.abs(v) - 1);
}
```

Это необычный способ узнать, чётное ли число, но иллюстрирует идею: некоторые алгоритмы удобно выражать через взаимную рекурсию.

Фибоначчи тоже можно выразить через взаимную рекурсию:

```js
function fib_(n) {
    if (n == 1) return 1;
    else return fib(n - 2);
}

function fib(n) {
    if (n == 0) return 0;
    else return fib(n - 1) + fib_(n);
}
```

**Примечание:** Этот вариант взят из исследования ["Fibonacci Numbers Using Mutual Recursion"](https://www.researchgate.net/publication/246180510_Fibonacci_Numbers_Using_Mutual_Recursion).

Хотя эти примеры искусственны, во многих случаях (например, при работе с деревьями) взаимная рекурсия бывает полезной.

### Зачем рекурсия?

Зачем использовать рекурсию?

Главная причина: рекурсия убирает явное управление состоянием и перекладывает его на стек вызовов. Обычно рекурсия отлично подходит для задач, где в императивном стиле пришлось бы писать циклы и вручную управлять промежуточными результатами.

Пример обычной и рекурсивной суммы:

```js
function sum(total, ...nums) {
    for (let num of nums) {
        total = total + num;
    }
    return total;
}

// vs

function sum(num1, ...nums) {
    if (nums.length == 0) return num1;
    return num1 + sum(...nums);
}
```

Второй вариант — рекурсивный — избавляет от цикла и промежуточного состояния.

Чем сложнее алгоритм, тем больше пользы вы получите от рекурсии вместо явного цикла.

## Декларативная рекурсия

В математике часто используют символ суммы **Σ** для обозначения суммирования. Это декларативно и понятно — решение задачи есть, но детали скрыты.

Рекурсия также декларативна для алгоритмов. Она говорит: «решение есть», а детали — скрыты в механике рекурсивных вызовов.

Пример императивного поиска максимального чётного числа:

```js
function maxEven(...nums) {
    var maxNum = -Infinity;
    for (let num of nums) {
        if (num % 2 == 0 && num > maxNum) {
            maxNum = num;
        }
    }
    if (maxNum !== -Infinity) {
        return maxNum;
    }
}
```

Вариант через рекурсию:

```js
function maxEven(num1, ...restNums) {
    var maxRest = restNums.length > 0 ?
        maxEven(...restNums) :
        undefined;

    return (num1 % 2 != 0 || num1 < maxRest) ?
        maxRest :
        num1;
}
```

Такой код ближе к декларативному математическому определению. Он избавлен от лишнего «шума» — весь цикл и промежуточное состояние «спрятаны» в рекурсивных вызовах.

**Совет:** Часто такие задачи можно выразить ещё проще через методы массива (`filter`, `reduce`), о чём поговорим в [главе 9](ch9.md).

### Рекурсия на бинарных деревьях

Пример: вычисление глубины бинарного дерева. Почти все операции с деревьями проще всего выражать через рекурсию.

Глубина дерева — это длина самого длинного пути от корня к листу. Рекурсивное определение:

```txt
depth(node):
    1 + max(depth(node.left), depth(node.right))
```

Код:

```js
function depth(node) {
    if (node) {
        let depthLeft = depth(node.left);
        let depthRight = depth(node.right);
        return 1 + Math.max(depthLeft, depthRight);
    }
    return 0;
}
```

Императивный вариант был бы гораздо запутаннее.

Не все задачи идеально ложатся на рекурсию, но для многих структур (деревья, графы) она незаменима.

## Стек

Вернёмся к рекурсии `isOdd(..)`/`isEven(..)`:

```js
function isOdd(v) {
    if (v === 0) return false;
    return isEven(Math.abs(v) - 1);
}

function isEven(v) {
    if (v === 0) return true;
    return isOdd(Math.abs(v) - 1);
}
```

Если вызвать `isOdd(33333)`, то получите ошибку:

```js
isOdd(33333); // RangeError: Maximum call stack size exceeded
```

Это происходит потому, что движок защищает вашу программу от переполнения памяти — стек вызовов заполнен.

Каждый вызов функции резервирует небольшой кусок памяти — стековый кадр (stack frame), где хранятся локальные переменные и параметры. Когда функция вызывает другую (или себя), добавляется ещё один кадр и так далее.

Пример для наглядности:

```js
function foo() { var z = "foo!"; }
function bar() { var y = "bar!"; foo(); }
function baz() { var x = "baz!"; bar(); }
baz();
```

Визуализация стековых кадров:

<p align="center">
    <img src="images/fig15.png" width="80%">
</p>

Если функции вызываются последовательно (foo, bar, baz), кадры не накапливаются — стек освобождается.

Главная проблема рекурсии — быстрое заполнение стека на больших данных. Поэтому движки ограничивают глубину стека.

### Хвостовые вызовы

Рекурсия появилась задолго до JS, как и проблема с памятью. В 1960-х заметили: если вызов функции происходит в самом конце другой функции (tail call), можно не держать предыдущий кадр в памяти.

<p align="center">
    <img src="images/fig16.png" width="80%">
</p>

Хвостовые вызовы особенно важны для рекурсии: стек может не расти, если новые вызовы происходят в хвосте, а старые кадры освобождаются.

Такие техники называются оптимизацией хвостовых вызовов (TCO — Tail Call Optimization).

### Корректные хвостовые вызовы (PTC)

В JS до ES6 не было требования поддерживать хвостовые вызовы. В ES6 появилась спецификация Proper Tail Calls (PTC): если функция вызывается в конце и её результат сразу возвращается, движок обязан освободить предыдущий стековый кадр.

PTC работает только в строгом режиме (`"use strict"`).

Правильный хвостовой вызов:

```js
return foo(..);
```

НЕ является PTC:

```js
foo();
return;
// или
var x = foo(..);
return x;
// или
return 1 + foo(..);
```

**Примечание:** Компилятор может оптимизировать некоторые из этих случаев, но не обязан.

Вот пример PTC с условием:

```js
return x ? foo(..) : bar(..);
```

В бинарной или множественной рекурсии (две и более ветви) PTC сложно реализовать, потому что не все вызовы будут в «хвосте».

Можно попытаться реорганизовать такие алгоритмы для PTC, разбив их на отдельные функции и используя взаимную рекурсию.

## Перестройка рекурсии

Если ваша задача может перерасти лимит стека, нужно перестроить код для использования PTC.

Главная цель — читаемость. Если после перестройки код стал хуже — лучше оставить императивный вариант.

### Замена стека

Проблема рекурсии — память под стек. Если можно избавиться от необходимости возвращать результат после рекурсивного вызова, стек больше не нужен.

Пример:

```js
function sum(num1, ...nums) {
    if (nums.length == 0) return num1;
    return num1 + sum(...nums);
}
```

Здесь после рекурсивного вызова делается сложение — поэтому стек нужен.

Можно изменить сигнатуру:

```js
"use strict";
function sum(result, num1, ...nums) {
    result = result + num1;
    if (nums.length == 0) return result;
    return sum(result, ...nums);
}
```

Теперь PTC! Но теперь при вызове нужно явно передавать начальный результат:

```js
sum(0, 3, 1, 17, 94, 8); // 123
```

Обычно делают обёртку:

```js
"use strict";
function sumRec(result, num1, ...nums) {
    result = result + num1;
    if (nums.length == 0) return result;
    return sumRec(result, ...nums);
}

function sum(...nums) {
    return sumRec(0, ...nums);
}
```

Или внутреннюю функцию:

```js
"use strict";
function sum(...nums) {
    return sumRec(0, ...nums);
    function sumRec(result, num1, ...nums) {
        result = result + num1;
        if (nums.length == 0) return result;
        return sumRec(result, ...nums);
    }
}
```

Можно упростить сигнатуру, используя первые два числа как промежуточный результат:

```js
"use strict";
function sum(num1, num2, ...nums) {
    num1 = num1 + num2;
    if (nums.length == 0) return num1;
    return sum(num1, ...nums);
}
```

Для других задач (например, maxEven) можно применить похожий подход.

### Continuation Passing Style (CPS)

В JS continuation — это функция-коллбэк, указывающая следующий шаг после завершения работы.

Некоторые формы рекурсии невозможно переписать в PTC (например, множественная рекурсия). Тогда можно использовать CPS: первый рекурсивный вызов делается напрямую, остальные — передаются как continuation.

Пример для Фибоначчи:

```js
"use strict";
function fib(n, cont = identity) {
    if (n <= 1) return cont(n);
    return fib(
        n - 2,
        n2 => fib(
            n - 1,
            n1 => cont(n2 + n1)
        )
    );
}
```

CPS сложнее читать, но позволяет избежать переполнения стека. Однако функции-замыкания всё равно занимают память.

### Трамплины

Трамплин (trampoline) — альтернатива CPS: вместо вызова функции мы возвращаем следующую функцию, а внешний цикл вызывает их по очереди, пока не получит результат.

```js
function trampoline(fn) {
    return function trampolined(...args) {
        var result = fn(...args);
        while (typeof result == "function") {
            result = result();
        }
        return result;
    };
}
```

Пример использования:

```js
var sum = trampoline(
    function sum(num1, num2, ...nums) {
        num1 = num1 + num2;
        if (nums.length == 0) return num1;
        return () => sum(num1, ...nums);
    }
);

var xs = [];
for (let i = 0; i < 20000; i++) {
    xs.push(i);
}
sum(...xs); // 199990000
```

Трамплин менее навязчив с точки зрения стиля: не нужно менять сигнатуру функции.

## Итог

Рекурсия — это когда функция вызывает себя. (Ха-ха, рекурсивное определение!)

Прямая рекурсия — когда функция вызывает себя одну или несколько раз до достижения базового условия. Множественная — когда на каждом шаге происходит несколько рекурсивных вызовов.

Плюсы рекурсии — декларативность и читаемость, минусы — производительность и память.

Хвостовые вызовы облегчают нагрузку на стек, но требуют строгого режима и правильной структуры кода. Есть приёмы (PTC, CPS, трамплин), чтобы использовать рекурсию без переполнения стека.

Помните: рекурсия должна помогать читаемости. Если вы усложнили код ради рекурсии, лучше использовать обычные циклы.
