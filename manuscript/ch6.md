# Functional-Light JavaScript
# Глава 6: Неизменяемость значений

В [главе 5](ch5.md) мы говорили о важности уменьшения побочных причин/эффектов — способов, которыми состояние вашего приложения может измениться неожиданно и привести к багам. Чем меньше мест для таких изменений, тем проще поддерживать и проверять код.

Если идемпотентность в программировании — это про то, чтобы операция изменения значения могла повлиять на состояние только один раз, то дальше мы поговорим о том, как уменьшить само количество таких изменений.

Теперь мы рассмотрим неизменяемость значений: идею о том, что в наших программах мы используем только значения, которые нельзя изменить.

## Неизменяемость примитивов

Значения примитивных типов (`number`, `string`, `boolean`, `null`, `undefined`) уже неизменяемы — вы не можете их изменить:

```js
// некорректно и не имеет смысла
2 = 2.5;
```

Однако, в JS есть странность, которая кажется, будто позволяет мутировать такие значения: "обёртки" (boxing). Когда вы обращаетесь к свойству примитива — например, `number` или `string` — движок временно оборачивает его в объект.

Пример:

```js
var x = 2;

x.length = 4;

x;              // 2
x.length;       // undefined
```

У числа нет свойства `length`, поэтому попытка его добавить тихо игнорируется (или выбрасывает ошибку в строгом режиме).

Если попробовать мутировать явно обёрнутый объект:

```js
var x = new Number(2);

// работает
x.length = 4;
```

Здесь `x` — объект, поэтому можно добавлять свойства.

Неизменяемость примитивов вроде чисел очевидна. А как насчёт строк? Многие JS-разработчики ошибочно думают, что строки можно менять, как массивы:

```js
var s = "hello";

s[1];               // "e"

s[1] = "E";
s.length = 10;

s;                  // "hello"
```

Доступ по индексу работает, но изменение — нет. В строгом режиме будут ошибки.

Даже обёрнутый объект `String` ведёт себя неизменяемо (в основном):

```js
"use strict";

var s = new String("hello");

s[1] = "E";         // ошибка
s.length = 10;      // ошибка

s[42] = "?";        // можно

s;                  // "hello"
```

## Значение к значению

Неизменяемость значений не означает, что значения в программе не меняются совсем. Это значит, что **если** нам нужно изменить состояние, мы создаём и отслеживаем новое значение, вместо мутации существующего.

Пример:

```js
function addValue(arr) {
    var newArr = [ ...arr, 4 ];
    return newArr;
}

addValue([1,2,3]);    // [1,2,3,4]
```

Мы не изменили исходный массив — создали новый с добавленным значением.

Если `[1,2,3]` — это текущее состояние, то `[1,2,3,4]` — новое состояние. Мы полностью контролируем переход, и никакая другая часть программы не изменит состояние неожиданно.

Массив, на который ссылается `arr`, на самом деле мутируемый. Мы просто выбрали не мутировать его — это и есть дух неизменяемости значений.

То же можно делать и с объектами:

```js
function updateLastLogin(user) {
    var newUserRecord = Object.assign({}, user);
    newUserRecord.lastLogin = Date.now();
    return newUserRecord;
}

var user = { /* ... */ };

user = updateLastLogin(user);
```

### Не локально

Непримитивные значения передаются по ссылке, и если их передать функции, та может изменить их через эту ссылку.

```js
var arr = [1,2,3];

foo(arr);

console.log(arr[0]);
```

Ожидаете, что `arr[0]` всё ещё равно 1? Не факт: функция могла изменить массив.

Чтобы избежать этого, передавайте копии:

```js
var arr = [1,2,3];

foo([...arr]);

console.log(arr[0]); // 1
```

Позже мы посмотрим ещё один способ защиты от неожиданных мутаций.

## Переназначение

Что такое "константа"? Многие скажут: "значение, которое нельзя поменять". Но это не совсем так. Константа — это переменная, которую нельзя переназначить (reassign), но значение внутри может быть изменяемым.

```js
var x = 2;
```

`2` — неизменяемое примитивное значение. Если заменить на:

```js
const x = 2;
```

`const` не меняет природу `2`. Просто переменную `x` нельзя переназначить:

```js
x = 3; // Ошибка!
```

Но если:

```js
const x = [2];
x[0] = 3; // OK!
```

Массив можно менять, хотя переменная `x` — константа.

Использование `const` часто переоценивают: это всего лишь сигнал о том, что переменная не будет переназначена. На практике этот сигнал полезен только в небольших локальных блоках, где и так видно, что переменная не меняется.

Более того, читатель может ошибочно подумать, что, например, `const magicNums = [1,2,3,4];` — это неизменяемый массив, хотя это не так.

Ещё хуже, если вы потом мутируете этот массив: читатель может принять неверное решение о его состоянии.

**Лучше использовать `var` или `let` для изменяемых переменных, а `const` — только для реально неизменяемых значений, вроде числовых констант**:

```js
const PI = 3.141592;
```

Ограничение reassignment-а — не главное; важно, мутируется ли значение.

FP часто избегает reassignment из-за идеи "равенства по уравнениям" (equational reasoning) — это облегчает анализ программ. Но в JS разумное использование reassignment может быть удобнее и читаемее:

```js
var a = "420";
a = Number(a);
a = [a];
```

Главное — не то, переназначаем ли переменную, а **мутируем ли значение**. Значения "переносятся" между областями видимости, а переменные — нет.

### Заморозка

Лёгкий способ сделать объект/массив/функцию "неизменяемым":

```js
var x = Object.freeze([2]);
```

`Object.freeze(..)` делает все свойства/элементы объекта только для чтения. Но только на верхнем уровне! Вложенные объекты не защищены:

```js
var x = Object.freeze([2, 3, [4, 5]]);
x[0] = 42;      // нельзя
x[2][0] = 42;   // можно!
```

`Object.freeze(..)` даёт поверхностную (shallow) неизменяемость. Для глубокой — надо рекурсивно замораживать всё.

В отличие от `const`, который может ввести в заблуждение, `Object.freeze(..)` действительно делает значение неизменяемым.

Пример защиты:

```js
var arr = Object.freeze([1,2,3]);
foo(arr);
console.log(arr[0]); // 1
```

Теперь можно быть уверенным, что значение не изменится.

## Производительность

Если каждый раз при изменении состояния вы создаёте новый массив или объект вместо мутации, возникает вопрос: как это влияет на производительность?

Если изменения редки — не страшно. Если часто и на критичном пути — это важно.

Существуют специальные структуры для "неявной" неизменяемости, например, persistent data structures. Внутри они обычно используют дерево ссылок, где каждый узел — новый diff. Похожая концепция используется в **Git**.

<p align="center">
    <img src="images/fig18.png" width="33%">
</p>

Пример использования такой структуры (в виде библиотеки Immutable.js):

```js
var state = Immutable.List.of(4, 6, 1, 1);

var newState = state.set(4, 2);

state === newState;                 // false

state.get(2);                       // 1
state.get(4);                       // undefined

newState.get(2);                    // 1
newState.get(4);                    // 2

newState.toArray().slice(2, 5);     // [1,1,2]
```

Immutable.js реализует множество оптимизаций. Делать всё это вручную — сложно и не нужно.

Если изменений мало и производительность не критична — используйте `Object.freeze(..)`.

## Отношение к значениям

Если вы получили значение в функцию и не знаете, мутируемо оно или нет, **нельзя просто брать и мутировать его**.

Пример:

```js
function updateLastLogin(user) {
    var newUserRecord = Object.assign({}, user);
    newUserRecord.lastLogin = Date.now();
    return newUserRecord;
}
```

Здесь мы работаем с `user` как с неизменяемым значением. А если так:

```js
function updateLastLogin(user) {
    user.lastLogin = Date.now();
    return user;
}
```

Это проще, но мутирует исходный объект и делает функцию нечистой.

**Всегда относитесь к входящим значениям как к неизменяемым**, даже если вы точно не знаете, что это так. Это повышает читаемость и доверие к коду.

Многие стандартные методы массива следуют этому принципу: `concat(..)`, `slice(..)`, `map(..)`, `filter(..)`, `reduce(..)` — все возвращают новый массив, не мутируя исходный. Но методы вроде `splice(..)`, `pop(..)`, `push(..)`, `reverse(..)`, `sort(..)` мутируют массив.

Использовать такие методы не запрещено, но их нельзя применять к значениям, которые пришли извне и могли быть нужны ещё где-то.

<a name="hiddenmutation"></a>

Пример скрытой мутации:

```js
function compose(...fns) {
    return function composed(result){
        var list = [...fns];
        while (list.length > 0) {
            result = list.pop()(result);
        }
        return result;
    };
}
```

Здесь мы копируем массив функций, чтобы не мутировать внешний.

Если не скопировать:

```js
function compose(...fns) {
    return function composed(result){
        while (fns.length > 0) {
            result = fns.pop()(result);
        }
        return result;
    };
}
```

Повторный вызов приведёт к ошибке, так как массив функций был изменён.

**Дисциплинированно относитесь к любым получаемым значениям как к неизменяемым** — это улучшает читаемость и надёжность кода.

## Итог

Неизменяемость значений — это не про то, чтобы значения не менялись вообще. Это про то, чтобы при изменении состояния создавать новые значения, а не мутировать существующие. Такой подход облегчает контроль над состоянием и уменьшает количество багов.

Объявления через `const` часто ошибочно воспринимаются как способ сделать значения неизменяемыми. На самом деле, `const` почти никак не влияет на неизменяемость значений и часто только запутывает.

Если производительность критична или данных очень много, создание новых массивов/объектов может быть затратным. В остальных случаях дисциплина работы с неизменяемыми значениями — ключ к читаемому и надёжному коду.
