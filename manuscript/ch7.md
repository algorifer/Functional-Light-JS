# Functional-Light JavaScript
# Глава 7: Замыкание против объекта

Несколько лет назад Антон ван Страатен сочинил ставшую известной и часто цитируемую [коан](https://www.merriam-webster.com/dictionary/koan), чтобы проиллюстрировать и вызвать размышления о важном противоречии между замыканиями и объектами в программировании:

> Почтенный мастер Qc Na шёл со своим учеником Антоном. Надеясь вызвать у мастера обсуждение, Антон сказал: «Мастер, я слышал, что объекты — это очень хорошо, это правда?» Qc Na с сожалением посмотрел на ученика и ответил: «Глупый ученик — объекты всего лишь замыкания для бедных».
>
> Пристыженный, Антон ушёл в свою келью, решив изучить замыкания. Он внимательно прочитал всю серию «Lambda: The Ultimate…» и её аналоги, реализовал маленький Scheme-интерпретатор с объектной системой на замыканиях. Он многому научился и с нетерпением ждал, чтобы сообщить мастеру о своём прогрессе.
>
> На следующей прогулке с Qc Na Антон попытался произвести впечатление: «Мастер, я усердно изучал вопрос и теперь понимаю, что объекты — это действительно замыкания для бедных». Qc Na ударил Антона палкой и сказал: «Когда же ты поймёшь? Замыкания — это объекты для бедных». В этот момент Антон просветлел.
>
> -- Anton van Straaten 6/4/2003
>
> http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html

В оригинале этого поста есть больше контекста и мотивации — очень рекомендую прочитать его, чтобы правильно настроиться на эту главу.

Многие, кто читает эту коан, лишь улыбаются её остроумию, но не меняют своего мышления. Но цель коанов (в дзэн-буддизме) — не просто развлечение, а повод для глубоких размышлений.

Так кто же прав? Замыкание — это «объект для бедных», или объект — «замыкание для бедных»? Или ни то, ни другое? Или оба сразу? Являются ли они чем-то эквивалентным?

И как это связано с функциональным программированием? Устроьтесь поудобнее и задумайтесь. Эта глава — небольшое философское ответвление, экскурсия в сторону.

## На одной волне

Давайте для начала убедимся, что понимаем под замыканиями и объектами одно и то же. Мы в контексте JavaScript и говорим именно о JS-специфике.

Вот пример простого замыкания:

```js
function outer() {
    var one = 1;
    var two = 2;

    return function inner(){
        return one + two;
    };
}

var three = outer();

three();            // 3
```

И пример простого объекта:

```js
var obj = {
    one: 1,
    two: 2
};

function three(outer) {
    return outer.one + outer.two;
}

three(obj);       // 3
```

Многие при слове «замыкание» думают о коллбэках, модульном паттерне и сокрытии информации. При слове «объект» — о классах, наследовании, инкапсуляции. По ходу главы мы обсудим нюансы, но сейчас сосредоточьтесь на простейших трактовках, как выше.

## Похожи!

Неочевидно, как замыкания и объекты связаны. Давайте рассмотрим их сходства.

Во-первых, утверждение:

1. Язык без замыканий может симулировать их объектами.
2. Язык без объектов может симулировать их замыканиями.

То есть, это два разных способа выразить одну и ту же суть.

### Состояние

Рассмотрим код:

```js
function outer() {
    var one = 1;
    var two = 2;

    return function inner(){
        return one + two;
    };
}

var obj = {
    one: 1,
    two: 2
};
```

И в замыкании, и в объекте есть два состояния: one=1 и two=2. Синтаксически и технически — это разные представления одного и того же.

Например, объект как замыкание:

```js
function outer() {
    var x = 10;
    var y = 12;
    var z = 14;

    return function inner(){
        return [x, y, z];
    }
};

var point = outer();
```

**Примечание:** inner() возвращает каждый раз новый массив (т.е. объект!), потому что в JS нельзя вернуть несколько значений без упаковки.

Вложенные объекты:

```js
var person = {
    name: "Kyle Simpson",
    address: {
        street: "123 Easy St",
        city: "JS'ville",
        state: "ES"
    }
};
```

Аналогично — вложенные замыкания:

```js
function outer() {
    var name = "Kyle Simpson";
    return middle();

    function middle() {
        var street = "123 Easy St";
        var city = "JS'ville";
        var state = "ES";

        return function inner(){
            return [name, street, city, state];
        };
    }
}

var person = outer();
```

Замыкание как объект:

```js
function point(x1, y1) {
    return function distFromPoint(x2, y2){
        return Math.sqrt(
            Math.pow(x2 - x1, 2) +
            Math.pow(y2 - y1, 2)
        );
    };
}

var pointDistance = point(1, 1);

pointDistance(4, 5);      // 5
```

Аналог через объект:

```js
function pointDistance(point, x2, y2) {
    return Math.sqrt(
        Math.pow(x2 - point.x1, 2) +
        Math.pow(y2 - point.y1, 2)
    );
};

pointDistance({ x1: 1, y1: 1 }, 4, 5); // 5
```

### Поведение тоже!

И объекты, и замыкания могут содержать как данные, так и поведение (функции/методы). Совместное хранение данных и поведения называется инкапсуляцией.

Пример:

```js
function person(name, age) {
    return function happyBirthday(){
        age++;
        console.log(
            `Happy ${age}th Birthday, ${name}!`
        );
    }
}

var birthdayBoy = person("Kyle", 36);

birthdayBoy();          // Happy 37th Birthday, Kyle!
```

То же через объект:

```js
var birthdayBoy = {
    name: "Kyle",
    age: 36,
    happyBirthday() {
        this.age++;
        console.log(
            `Happy ${this.age}th Birthday, ${this.name}!`
        );
    }
};

birthdayBoy.happyBirthday();
// Happy 37th Birthday, Kyle!
```

В closure привязывается одна функция к набору данных, а объект может содержать любое количество методов.

Можно реализовать и несколько методов через замыкание:

```js
function createPerson(firstName, lastName) {
    return API;

    function API(methodName) {
        switch (methodName) {
            case "first": return first();
            case "last": return last();
        }
    }

    function first() { return firstName; }
    function last() { return lastName; }
}

var person = createPerson("Kyle", "Simpson");

person("first") + " " + person("last");
// Kyle Simpson
```

### (Не)изменяемость

Многие думают, что замыкания защищают от мутаций, а объекты — нет. Но на самом деле всё зависит от значения:

```js
function outer() {
    var x = 1;
    var y = [2,3];

    return function inner(){
        return [ x, y[0], y[1] ];
    };
}

var xyPublic = {
    x: 1,
    y: [2,3]
};
```

Примитивы неизменяемы. Но массив `y` — мутируемый в обоих случаях.

Можно выразить то же так:

```js
function outer() {
    var x = 1;
    return middle();

    function middle() {
        var y0 = 2;
        var y1 = 3;

        return function inner(){
            return [ x, y0, y1 ];
        };
    }
}

var xyPublic = {
    x: 1,
    y: {
        0: 2,
        1: 3
    }
};
```

На самом глубоком уровне все данные — примитивы, а они всегда неизменяемы.

### Изоморфизм

В JS «изоморфизм» — модное слово: обычно про код, работающий и на сервере, и в браузере. В общем смысле изоморфизм — это когда две вещи имеют одинаковую структуру (но не обязательно идентичны).

> Две сущности A и B изоморфны, если их можно сопоставить друг с другом и преобразовать туда-обратно без потери информации.

Как показали примеры выше, объекты и замыкания — изоморфные представления состояния и поведения.

### Под капотом

Можно представить, что замыкания реализованы через объекты:

```js
function outer() {
    var x = 1;
    return function inner(){
        return x;
    };
}
```

Где-то в памяти:

```js
scopeOfOuter = { x: 1 };
scopeOfInner = {};
Object.setPrototypeOf(scopeOfInner, scopeOfOuter);
```

И обращение к `x` — это поиск по цепочке прототипов. Это концепция, не реальная реализация, но во многих языках замыкания реализуют через объекты, а объекты — через замыкания.

## Две дороги...

Выходит, замыкания и объекты — одно и то же? Не совсем. Они похожи, но есть отличия.

И эти отличия — не «минусы», а особенности, делающие один или другой подход более подходящим для конкретной задачи.

### Структурная изменяемость

Структура closure неизменяема: нельзя добавить/удалить состояние после создания. Всё определяется на этапе объявления.

**Примечание:** Движок может оптимизировать closure, выбрасывая неиспользуемые переменные, но это прозрачно для разработчика.

А вот объекты — структурно изменяемы: можно добавлять/удалять свойства, если объект не заморожен через `Object.freeze(..)`.

Например, трекинг нажатий клавиш в игре:

```js
function trackEvent(evt, keypresses = []) {
    return [ ...keypresses, evt ];
}

var keypresses = trackEvent(newEvent1);
keypresses = trackEvent(newEvent2, keypresses);
```

В FP обычно массивы рассматривают как неизменяемые структуры: каждый раз создаём новый массив.

Можно сделать то же через замыкания:

```js
function trackEvent(evt, keypresses = () => []) {
    return function newKeypresses() {
        return [ ...keypresses(), evt ];
    };
}

var keypresses = trackEvent(newEvent1);
keypresses = trackEvent(newEvent2, keypresses);
```

Каждое добавление — это новая функция, замыкающая новое состояние.

В большинстве случаев массивы (и объекты) удобнее для таких задач.

### Приватность

Одна из очевидных разниц: closure позволяет скрывать состояние (private), а объекты всё делают публичным:

```js
function outer() {
    var x = 1;
    return function inner(){
        return x;
    };
}

var xHidden = outer();
xHidden(); // 1

var xPublic = { x: 1 };
xPublic.x; // 1
```

Для большого количества данных объект проще: можно заитерировать по ключам напрямую:

```js
function recordKeypress(keypressEvt) {
    DB.store("keypress-events", keypressEvt);
}

keypresses.forEach(recordKeypress);
```

Если «список» скрыт в closure, нужен специальный API (например, `forEach` внутри closure), чтобы итерировать данные.

#### Контроль изменений

Лексические переменные внутри closure можно переназначить только внутри closure. Это уменьшает поверхность для багов — только локальный код может менять значения.

У объекта свойства публичны — кто угодно ссылается на объект, тот и может их изменить. Частично помогает `Object.freeze(..)`, но это всё или ничего и необратимо.

Closure удобнее, если хочется разрешить изменения, но только в пределах небольшой области видимости.

Многие FP-разработчики вообще не используют reassignment, а для «заморозки» используют `Object.freeze(..)` или полноценные immutable-структуры.

Эта книга — про *Functional-Light*, и здесь допустимо использовать reassignment, если это повышает читаемость.

### Клонирование состояния

Как мы обсуждали в [главе 6](ch6.md), чтобы избежать побочных эффектов, мы должны делать копии объектов/массивов перед изменениями.

Массив:

```js
var a = [1, 2, 3];
var b = [...a];
b.push(4);
```

Объект:

```js
var o = { x: 1, y: 2 };
var p = { ...o };
p.y = 3;
// или:
var p = Object.assign({}, o);
p.y = 3;
```

Если значения внутри объекта/массива — тоже объекты, для глубокой копии придётся рекурсивно копировать всё.

А вот состояние в closure скопировать сложно: нужно явно экспортировать API для извлечения данных из closure на каждом уровне вложенности.

Объекты здесь гораздо удобнее.

### Производительность

Объекты часто легче по памяти и скорости, чем closure, но это не всегда так. Многое зависит от реализации и сценария.

Пример closure:

```js
function StudentRecord(name, major, gpa) {
    return function printStudent() {
        return `${name}, Major: ${major}, GPA: ${gpa.toFixed(1)}`;
    };
}

var student = StudentRecord("Kyle Simpson", "CS", 4);
student(); // Kyle Simpson, Major: CS, GPA: 4.0
```

Аналог через объект и `this`:

```js
function StudentRecord() {
    return `${this.name}, Major: ${this.major}, GPA: ${this.gpa.toFixed(1)}`;
}

var student = StudentRecord.bind({
    name: "Kyle Simpson",
    major: "CS",
    gpa: 4
});
student(); // Kyle Simpson, Major: CS, GPA: 4.0
```

`bind(..)` тоже можно реализовать через closure:

```js
function bind(origFn, thisObj) {
    return function boundFn(...args) {
        return origFn.apply(thisObj, args);
    };
}

var student = bind(StudentRecord, { name: "Kyle.." });
```

В современных JS-движках bound-функции очень быстры, иногда даже быстрее closure.

Вывод: производительность зависит от ситуации, не делайте выводов без проверки.

## Итог

Истинный смысл этой главы нельзя записать словами. Его нужно прочувствовать.

----

(Чуть-чуть дзен:))

А если серьёзно: объекты и замыкания — изоморфны. Их можно использовать взаимозаменяемо для представления состояния и поведения.

Closure дают более тонкий контроль над изменениями и автоматическую приватность. Объекты удобнее для клонирования состояния.

Вдумчивый FP-разработчик может реализовать любую часть программы и так, и эдак — и выбрать подходящий вариант под конкретную задачу.
