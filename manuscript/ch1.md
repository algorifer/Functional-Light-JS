# Functional-Light JavaScript
# Глава 1: Почему функциональное программирование?

> Функциональный программист: (сущ.) Тот, кто называет переменные "x", функции — "f", а шаблоны кода — "zygohistomorphic prepromorphism"
>
> Джеймс Айри @jamesiry 13.05.2015
>
> https://twitter.com/jamesiry/status/598547781515485184

Функциональное программирование (FP) — далеко не новая концепция. Оно существует практически столько же, сколько и сама история программирования. Однако, и не уверен, будет ли это справедливо сказать, но... похоже, особо популярным оно не было...

Но всё меняется. FP всё больше привлекает к себе внимание, и не только на уровне языков, но и в библиотеках и фреймворках. Возможно, вы читаете этот текст именно потому, что чувствуете этот сдвиг — а может быть, вы всё ещё скептически относитесь к FP и хотите разобраться, что же в нём такого особенного.

Цель этой первой главы — ответить на вопросы вроде «Зачем мне использовать стиль FP в своём коде?» и «Чем Functional-Light JavaScript отличается от других подходов к FP?». После того как мы разберём эти основы, вы сможете решить для себя, стоит ли погружаться глубже.

## В двух словах

Давайте кратко иллюстрируем концепцию "Functional-Light JavaScript" на примере: до и после. Рассмотрим такой код:

```js
var numbers = [4,10,0,27,42,17,15,-6,58];
var faves = [];
var magicNumber = 0;

pickFavoriteNumbers();
calculateMagicNumber();
outputMsg();                // The magic number is: 42

// ***************

function calculateMagicNumber() {
    for (let fave of faves) {
        magicNumber = magicNumber + fave;
    }
}

function pickFavoriteNumbers() {
    for (let num of numbers) {
        if (num >= 10 && num <= 20) {
            faves.push( num );
        }
    }
}

function outputMsg() {
    var msg = `The magic number is: ${magicNumber}`;
    console.log( msg );
}
```

А теперь рассмотрим другой стиль, который достигает того же результата:

```js
var sumOnlyFavorites = FP.compose( [
    FP.filterReducer( FP.gte( 10 ) ),
    FP.filterReducer( FP.lte( 20 ) )
] )( sum );

var printMagicNumber = FP.pipe( [
    FP.reduce( sumOnlyFavorites, 0 ),
    constructMsg,
    console.log
] );

var numbers = [4,10,0,27,42,17,15,-6,58];

printMagicNumber( numbers );        // The magic number is: 42

// ***************

function sum(x,y) { return x + y; }
function constructMsg(v) { return `The magic number is: ${v}`; }
```

Когда вы разберётесь с FP и Functional-Light, вы, скорее всего, будете *читать* и воспринимать второй фрагмент примерно так:

> Сначала мы создаём функцию `sumOnlyFavorites(..)`, которая объединяет три другие функции. Мы комбинируем два фильтра: первый проверяет, больше ли значение или равно 10, второй — меньше ли оно или равно 20. Эти фильтры отбирают нужные числа, а затем мы их складываем.
>
> Затем мы создаём функцию `printMagicNumber(..)`, которая сначала сводит список чисел к сумме отобранных, затем превращает результат в строку-сообщение, а потом выводит это сообщение в консоль.

Все эти элементы *говорят* FP-разработчику на понятном ему языке, который поначалу может показаться вам непривычным. Эта книга поможет вам научиться *думать* и *читать* код в таком стиле.

Пару замечаний по сравнению этих двух подходов:

* Для многих читателей первый вариант будет более привычным, понятным и поддерживаемым, чем второй. Это абсолютно нормально! Вы находитесь именно там, где нужно, чтобы начать учиться новому.
* Возможно, вы бы решили задачу совсем иначе — это тоже нормально. Эта книга не будет диктовать единственно верный способ решения — мы будем изучать разные подходы.
* Быть может, вы уже опытный FP-разработчик и просто просматриваете начало книги в поисках новых идей. Второй вариант кода определённо содержит кое-что интересное для вас.

    Это не классическая книга по FP. Местами мы будем отклоняться от канонов. Мы ищем прагматичный баланс между несомненными преимуществами FP и теми требованиями, которые предъявляет реальный мир JavaScript.

Что бы ни привело вас к этой книге — добро пожаловать!

## Доверие

В качестве преподавателя программирования (на JavaScript) я всегда придерживаюсь одной простой идеи: коду, которому вы не доверяете — вы его не понимаете. И наоборот: то, что вы понимаете, вызывает у вас доверие.

Что я имею в виду под доверием? Это когда вы можете, просто читая и размышляя, а не только выполняя код, точно понять, что он *будет* делать. Вы не полагаетесь на то, что он *должен* делать, а действительно понимаете его поведение.

Техники, лежащие в основе FP, как раз и нацелены на то, чтобы вы могли гораздо больше доверять своему коду, просто читая его. Тот, кто понимает FP и применяет его дисциплинированно, чаще всего гораздо увереннее в том, что делает его программа.

Доверие также возрастает, когда мы используем техники, позволяющие избегать или минимизировать вероятные источники ошибок. Это, пожалуй, один из главных плюсов FP: такие программы, как правило, содержат меньше багов, а найденные ошибки проще локализовать и исправить.

По мере прохождения этой книги вы будете чувствовать всё большую уверенность в своём коде, ведь вы будете использовать проверенные практики и избегать типовых ошибок.

## Общение

Почему функциональное программирование важно? Чтобы ответить на этот вопрос, нужно сделать шаг назад и спросить: а зачем вообще мы программируем?

Возможно, это вас удивит, но я не считаю, что код — это прежде всего набор инструкций для компьютера. На самом деле, тот факт, что код что-то делает на компьютере — это почти случайное совпадение.

Я глубоко убеждён: куда важнее то, что код — это средство коммуникации между людьми.

Вы, наверное, и сами заметили: большая часть времени при "программировании" уходит не на написание нового кода, а на чтение уже существующего. Лишь немногие из нас могут позволить себе всё время только писать новый код.

По оценкам, 70% времени поддержки кода уходит на его чтение и понимание. Это впечатляет. Неудивительно, что в среднем программист пишет так мало строк в день.

Нам стоит уделять гораздо больше внимания читаемости кода. И, кстати, читаемость — это не только про сокращение количества символов. На неё больше всего влияет... знакомость.

Если мы хотим, чтобы код был максимально читаемым и понятным, FP — это один из лучших путей к этой цели. Принципы FP хорошо изучены, проверены на практике и делают код более узнаваемым.

Например, когда вы поймёте, что делает `map(..)`, вы будете сразу узнавать и понимать его в любом коде. А вот каждый раз, когда вы встречаете `for`, вам придётся вчитываться, чтобы разобраться, что происходит на этот раз.

Чем больше в нашем коде узнаваемых конструкций, тем меньше времени тратим на выяснение "что тут вообще происходит", и тем больше можем сосредоточиться на логике самой программы.

FP (особенно без перегруза терминологией) — один из самых эффективных инструментов для создания читаемого кода. Вот почему это важно.

## Читаемость

Читаемость — не бинарное свойство. Это субъективный человеческий фактор, который определяет наши отношения с кодом. И, конечно, она меняется по мере роста наших умений и опыта.

<p align="center">
    <img src="images/fig17.png" width="50%">
</p>

Возможно, по мере изучения книги вы испытаете похожие чувства. Но не отчаивайтесь: если вы будете идти дальше, кривая снова пойдёт вверх!

*Императивный* стиль — это тот, к которому мы чаще всего привыкли: он фокусируется на том, *как* что-то сделать. Декларативный код (а именно такой мы будем изучать) — это про то, *что* нужно получить.

Давайте ещё раз посмотрим на оба примера кода из начала главы.

Первый фрагмент — императивный: он сосредоточен на деталях, на "шаг за шагом", содержит множество `if`, циклов, временных переменных, изменений значений, вызовов функций с побочными эффектами.

Второй пример — декларативный: он избегает большинства указанных выше приёмов. Здесь нет явных условий, циклов, побочных эффектов, изменений переменных; есть только поток данных через набор понятных функций.

Вместо того чтобы писать `if`, мы делегируем эту задачу хорошо известной функции вроде `gte(..)` (больше или равно) — и можем сосредоточиться на логике обработки данных.

Более того, поток данных во втором примере явно выражен:

1. Список чисел передаётся в `printMagicNumber(..)`.
2. По очереди числа обрабатываются через `sumOnlyFavorites(..)`, получаем сумму только "любимых" чисел.
3. Эта сумма превращается в текстовое сообщение через `constructMsg(..)`.
4. Сообщение выводится в консоль через `console.log(..)`.

Возможно, вам всё ещё кажется этот подход запутанным, а императивный — проще. Это нормально: вы к нему более привычны, а знакомость сильно влияет на нашу оценку читаемости.

Я понимаю, что сейчас поверить в это нелегко.

Иногда приходится потратить больше усилий (и даже кода), чтобы сделать его читаемым, как я предлагаю, и минимизировать количество типичных ошибок. Честно говоря, когда я только начал применять FP, результат показался мне не слишком элегантным.

Если вы надеетесь, что рефакторинг под FP будет "серебряной пулей", которая моментально сделает код красивым, элегантным, лаконичным и надёжным — и что это будет легко — увы, вы разочаруетесь.

FP — это другой подход к тому, как структурировать код, чтобы поток данных был максимально прозрачен, а читатель мог следовать вашим мыслям. Это требует времени. Но усилия того стоят!

Сам я часто переделываю одну и ту же функцию несколько раз, прежде чем добиваюсь нужной ясности. Бывает, что спустя несколько дней я возвращаюсь к своему коду, чтобы проверить, могу ли я его "объяснить заново" — и если не могу, значит, нужно доработать.

Не подумайте, что я хочу вас отпугнуть. Я действительно рад, что прошёл через это! Теперь я вижу, как кривая снова идёт вверх — читаемость растёт. Это того стоит.

## Перспектива

Большинство других книг по FP идут "сверху вниз", а мы пойдём наоборот: будем двигаться "от земли", разбирая базовые принципы, на которых строится формальное FP.

Я считаю, что не так важно, как вы называете что-то, как то, насколько хорошо вы понимаете, что это и как работает. Хотя общая терминология тоже важна — она помогает общаться.

В этой книге мы будем больше фокусироваться на сути, а не на "навороченной" терминологии. Это не значит, что терминов не будет вовсе — но не стоит зацикливаться на сложных названиях.

Я называю этот менее формальный подход "Функциональное программирование-лайт" (Functional-Light Programming), потому что считаю: строгость формального FP может отпугнуть, если вы не привыкли к ней.

Я знаю многих FP-разработчиков, которые считают, что формализм помогает учиться. Возможно, это так — но только после того, как вы достигнете определённого уровня комфорта. Если вы пока не там — это нормально.

Так что эта книга познакомит вас с фундаментальными концепциями FP, но будет помогать "подтолкнуть снизу", а не "кричать сверху об истине".

## Как найти баланс

Если вы давно программируете, наверняка слышали принцип "YAGNI": "You Ain't Gonna Need It" ("Вам это не понадобится"). Этот принцип пришёл из экстремального программирования: не стоит реализовывать то, что не требуется прямо сейчас.

Порой мы думаем, что какая-то фича пригодится в будущем, заранее её реализуем, а потом оказывается — ошибались, и либо она не нужна, либо нужна совсем иначе.

YAGNI напоминает: даже если кажется, что "вдруг пригодится", чаще всего стоит отложить реализацию до тех пор, пока она реально не потребуется. Мы склонны переоценивать то, насколько "легко" будет добавить лишнее в процессе.

Если говорить про функциональное программирование, добавлю: здесь вы встретите много интересных паттернов, но если какой-то из них показался вам крутым — это ещё не значит, что его надо применять везде.

Вот чем я отличаюсь от многих "строгих" FP-адептов: если вы *можете* применить FP к задаче — не значит, что *должны*. И даже для одной задачи бывает несколько способов решения, и не все они одинаково хороши.

В целом, советую искать баланс и поначалу относиться к FP-концепциям осторожно. Ориентируйтесь на YAGNI, чтобы решить, стоит ли применять тот или иной паттерн.

> Напоминание: любая точка расширения, которая ни разу не используется — не только потраченное впустую время, но и потенциальная помеха для вас же
>
> Джереми Д. Миллер @jeremydmiller 20.02.2015
>
> https://twitter.com/jeremydmiller/status/568797862441586688

Помните: каждая строка кода — это затраты на чтение для кого-то: коллеги или вас самих в будущем. Никто не оценит излишнюю сложность.

Лучший код — тот, который спустя время остаётся максимально читаемым, потому что балансирует между идеалом и необходимостью.

## Ресурсы

Я опирался на множество материалов, чтобы написать эту книгу. Думаю, они будут полезны и вам — поэтому делюсь ими.

### Книги

Некоторые книги по FP и JavaScript, которые стоит прочесть:

* [Профессор Фрисби: В основном адекватное руководство по функциональному программированию](https://mostly-adequate.gitbook.io/mostly-adequate-guide/) (Brian Lonsdorf)
* [JavaScript Allongé](https://leanpub.com/javascriptallongesix) (Reg Braithwaite)
* [Functional JavaScript](http://shop.oreilly.com/product/0636920028857.do) (Michael Fogus)

### Блоги/сайты

Полезные авторы и ресурсы:

* [Fun Fun Function (видео)](https://www.youtube.com/watch?v=BMUiFMZr7vk) — Mattias P Johansson
* [Awesome FP JS](https://github.com/stoeffel/awesome-fp-js)
* [Kris Jenkins](http://blog.jenkster.com/2015/12/what-is-functional-programming.html)
* [Eric Elliott](https://medium.com/@_ericelliott)
* [James A Forbes](https://james-forbes.com/)
* [James Longster](https://github.com/jlongster)
* [André Staltz](http://staltz.com/)
* [Functional Programming Jargon](https://github.com/hemanth/functional-programming-jargon#functional-programming-jargon)
* [Functional Programming Exercises](https://github.com/InceptionCode/Functional-Programming-Exercises)

### Библиотеки

Большинство примеров в этой книге не используют сторонние библиотеки. Мы будем рассматривать, как реализовать каждую операцию на чистом JavaScript. Однако, когда вы перейдёте к реальным проектам, библиотека может пригодиться.

Важно: обязательно читайте документацию к функциям библиотеки, чтобы понимать, как они работают. Во многих из них вы найдёте похожие приёмы на те, что мы изучим.

Вот несколько популярных FP-библиотек для JavaScript, с которых можно начать:

* [Ramda](http://ramdajs.com)
* [lodash/fp](https://github.com/lodash/lodash/wiki/FP-Guide)
* [functional.js](http://functionaljs.com/)
* [Immutable.js](https://github.com/facebook/immutable-js)

[В приложении C мы подробнее рассмотрим эти и другие библиотеки](apC.md/#stuff-to-investigate).

## Итоги

У вас может быть множество причин читать эту книгу и разные ожидания от неё. В этой главе я объяснил, почему хочу, чтобы вы её прочли, и что вы из неё получите.

Функциональное программирование — это про написание кода на основе проверенных принципов, чтобы обрести доверие и уверенность в том, что вы пишете и читаете. Не стоит довольствоваться кодом, которому нельзя доверять.

Это суть Functional-Light JavaScript. Цель — научиться эффективно "разговаривать" с помощью кода, не утопая в горах специальной нотации и терминологии.

Путь к FP начинается с глубокого понимания природы функции. Этим мы и займёмся в следующей главе.

----

<a name="footnote-1"><sup>1</sup></a> Buse, Raymond P. L., and Westley R. Weimer. “Learning a Metric for Code Readability.” IEEE Transactions on Software Engineering, IEEE Press, July 2010, dl.acm.org/citation.cfm?id=1858996.
