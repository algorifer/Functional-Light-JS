# Functional-Light JavaScript
# Глава 10: Функциональная асинхронность

К этому моменту книги у вас есть все базовые концепции для фундамента FP, который я называю "Functional-Light Programming". В этой главе мы применим их к другой области — асинхронному программированию.

До сих пор почти всё, что мы делали, было синхронным: мы вызываем функции с входными данными и сразу получаем результат. Так можно решить множество задач, но далеко не все реальные задачи в программировании такие простые.

Наша цель — расширить мышление об управлении значениями в FP, чтобы распространить такие операции во времени. Мы увидим, что Observable (и Promises!) — отличный инструмент для этого.

## Время как состояние

Самое сложное состояние в вашем приложении — это время. Куда проще управлять состоянием, когда переходы происходят мгновенно и полностью под вашим контролем. Как только в игру вступает время и события, происходящие не по вашему расписанию, ситуация усложняется.

Вся суть FP в этой книге — сделать код легче для чтения, а значит — более надёжным и предсказуемым. Асинхронность ставит эти усилия под угрозу: появляется больше неопределённости.

Но проблема не в том, что какие-то операции завершаются не сразу; запускать асинхронную работу несложно. Сложность — в координации результатов и управлении состоянием, когда время становится фактором.

Так кто должен брать на себя эту сложность — вы, автор кода, или читатель, пытающийся разобраться, в каком состоянии будет программа, если A завершится раньше B, или наоборот?

### Сведение времени к минимуму

Одна из важнейших задач асинхронных паттернов — упростить управление изменениями состояния, абстрагируя время. Посмотрим пример:

```js
var customerId = 42;
var customer;

lookupCustomer( customerId, function onCustomer(customerRecord){
    var orders = customer ? customer.orders : null;
    customer = customerRecord;
    if (orders) {
        customer.orders = orders;
    }
} );

lookupOrders( customerId, function onOrders(customerOrders){
    if (!customer) {
        customer = {};
    }
    customer.orders = customerOrders;
} );
```

Здесь callbacks `onCustomer(..)` и `onOrders(..)` находятся в гоночном состоянии. Кто из них выполнится первым — неизвестно.

Если бы мы могли вложить вызов `lookupOrders(..)` внутрь `onCustomer(..)`, то порядок был бы гарантирован, но нам нужно запускать оба запроса одновременно.

Чтобы упростить сложность времени, мы используем проверки через `if` и внешнюю переменную `customer`. Когда оба callback-а отработают, мы получим нужный результат — но читаемость кода страдает.

Перепишем с помощью Promise:

```js
var customerId = 42;

var customerPromise = lookupCustomer(customerId);
var ordersPromise = lookupOrders(customerId);

customerPromise.then(function onCustomer(customer){
    ordersPromise.then(function onOrders(orders){
        customer.orders = orders;
    });
});
```

Теперь `onOrders(..)` гарантированно вызывается после `onCustomer(..)`. Параллельность достигается тем, что оба запроса запускаются независимо, но упорядоченность — благодаря Promise.

Если бы lookupOrders завершился раньше lookupCustomer, то Promise гарантирует, что `then` для orders выполнится только после того, как будет получен customer.

Promise — это способ представить будущее значение независимо от времени. Получить значение из Promise — это асинхронный аналог синхронного присваивания.

Давайте посмотрим, как можно распространить типовые FP-операции во времени.

## Жадность против ленивости

В информатике "жадный" (eager) и "ленивый" (lazy) — это не оскорбления, а описание того, когда происходит операция: сразу или постепенно.

Все FP-операции, что мы видели, были жадными — работали синхронно с уже готовыми значениями.

Пример:

```js
var a = [1,2,3];
var b = a.map(v => v * 2);
b; // [2,4,6]
```

Этот map работает над всеми значениями здесь и сейчас. Если позже добавить значение в a, b не изменится.

А что если map был бы ленивым? Например:

```js
var a = [];
var b = mapLazy(a, v => v * 2);

a.push(1);
a[0]; // 1
b[0]; // 2

a.push(2);
a[1]; // 2
b[1]; // 4
```

Здесь mapLazy "следит" за a, и при каждом добавлении элемента вычисляет новое значение в b.

**Примечание:** Такой mapLazy — вымышленный, для иллюстрации. В реальности нужна инфраструктура для отслеживания изменений массива.

Главная идея: было бы удобно иметь b, автоматически обновляющийся при изменениях в a — декларативное описание потока данных во времени.

## Реактивное FP

Чтобы реализовать ленивое отображение между двумя наборами значений, нужно абстрагироваться от обычного массива. Представим "умный" массив:

```js
var a = new LazyArray();

var b = a.map(function double(v) {
    return v * 2;
});

setInterval(function everySecond() {
    a.push(Math.random());
}, 1000);
```

Этот LazyArray работает не с существующим набором значений, а с потоком — значения появляются со временем.

В отличие от обычного массива, значения не обязательно накапливаются в памяти — их можно сразу обрабатывать и забывать.

Чтобы узнать о появлении нового значения в b, нам нужен механизм подписки:

```js
b.listen(function onValue(v) {
    console.log(v);
});
```

b — *реактивный*: он реагирует на новые значения в a. Операция map описывает, как данные "текут" из a в b, а listen — что делать с каждым новым значением.

**Примечание:** Обычно это называют FRP (Functional Reactive Programming), но термин спорный. Здесь мы просто показываем FP + реактивность.

Мы можем разделить роли a (producer) и b (consumer):

```js
// producer
var a = new LazyArray();
setInterval(function everySecond() {
    a.push(Math.random());
}, 1000);

// consumer
var b = a.map(function double(v) {
    return v * 2;
});
b.listen(function onValue(v) {
    console.log(v);
});
```

a — источник событий, b — их обработчик.

Время теперь неявно — оно не прописано жёстко в логике обработки данных. Весь "временной" аспект вынесен в producer.

### Декларативное время

Внимательно подходя к вопросу времени, мы видим: Promise абстрагирует время для одного значения, а реактивное FP — для потока значений.

Для b не важно, откуда и когда приходят значения в a. Всё, что важно, — обработать каждое из них.

Такой подход делает код более читаемым: временные связи описываются декларативно, а не императивно.

Императивный способ выглядел бы так:

```js
var a = {
    onValue(v) {
        b.onValue(v);
    }
};
setInterval(function everySecond() {
    a.onValue(Math.random());
}, 1000);

var b = {
    map(v) {
        return v * 2;
    },
    onValue(v) {
        v = this.map(v);
        console.log(v);
    }
};
```

Здесь явно прописано, как значения передаются от a к b, что хуже для читабельности.

В декларативном варианте (через map/listen) b "подписан" на a, и не заботится о деталях.

### Не только map

Такой подход применим и к другим операциям FP. Например:

```js
var b = a.filter(function isOdd(v) {
    return v % 2 == 1;
});
b.listen(function onlyOdds(v) {
    console.log("Odd:", v);
});
```

Или reduce во времени:

```js
var b = a.reduce(function sum(total, v) {
    return total + v;
});
b.listen(function runningTotal(v) {
    console.log("New current total:", v);
});
```

Здесь b помнит предыдущее значение total и обновляет его при каждом новом v.

Другие FP-операции во времени могут требовать буфера — например, unique должен помнить все уже встречавшиеся значения.

### Observable

Такие реактивные структуры уже существуют — это Observable (наблюдаемые).

**Примечание:** Это только краткое введение в Observables. Тема гораздо шире, и если заинтересует, изучите подробно.

Самые известные библиотеки: [RxJS](https://github.com/Reactive-Extensions/RxJS) и [Most](https://github.com/cujojs/most).

Пример с RxJS:

```js
// producer
var a = new Rx.Subject();
setInterval(function everySecond() {
    a.next(Math.random());
}, 1000);

// consumer
var b = a.map(function double(v) {
    return v * 2;
});
b.subscribe(function onValue(v) {
    console.log(v);
});
```

В RxJS наблюдатель (Observer) подписывается на Observable. Если объединить их — получится Subject.

Можно разделить Observer и Observable:

```js
var a = Rx.Observable.create(function onObserve(observer) {
    setInterval(function everySecond() {
        observer.next(Math.random());
    }, 1000);
});
```

В RxJS есть сотни операторов, которые можно комбинировать цепочкой:

```js
var b =
    a
    .filter(v => v % 2 == 1)      // только нечётные
    .distinctUntilChanged()       // только разные подряд
    .throttle(100)                // немного замедлить поток
    .map(v => v * 2);             // удваиваем

b.subscribe(function onValue(v) {
    console.log("Next:", v);
});
```

**Примечание:** Каждая операция возвращает новый Observable, что удобно для композиции.

## Итоги

В этой книге мы рассмотрели множество FP-операций, работающих с одним или списком значений.

Все эти принципы можно перенести во время: как Promises моделируют одиночное значение в будущем, так Observables моделируют поток значений со временем.

`map(..)` над массивом применяет функцию к каждому уже существующему элементу; `map(..)` над Observable применяет функцию к каждому новому значению по мере его появления.

Иными словами, если массив — это eager-структура для FP-операций, то Observable — её ленивый (во времени) аналог.

**Примечание:** Для другого взгляда на асинхронный FP посмотрите библиотеку [**fasy** — см. приложение C](apC.md/#bonus-2-fasy).
