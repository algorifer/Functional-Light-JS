# Functional-Light JavaScript
# Глава 2: Природа функций

Функциональное программирование — **это не просто программирование с использованием ключевого слова `function`.** О, если бы всё было так просто — я мог бы закончить книгу прямо здесь! Тем не менее, функции действительно *лежат* в самом центре FP.

Но насколько вы уверены, что по-настоящему понимаете, что такое *функция*?

В этой главе мы заложим основу для всей остальной книги, подробно рассмотрев фундаментальные аспекты функций. На самом деле, это обзор вещей, которые полезны даже обычному программисту, не увлекающемуся FP.

Будьте готовы: в функции гораздо больше, чем кажется на первый взгляд.

## Что такое функция?

Вопрос «Что такое функция?» на первый взгляд кажется очевидным: функция — это набор кода, который можно выполнить один или несколько раз.

Это определение разумно, но оно упускает важное, что является сутью *функции* с точки зрения FP. Давайте разберёмся в этом глубже.

### Краткий математический экскурс

Я обещал избегать математики, насколько это возможно, но давайте ненадолго посмотрим на фундаментальные вещи о функциях и графиках из алгебры, прежде чем двигаться дальше.

Помните, как в школе вы сталкивались с `f(x)`? Или с уравнением `y = f(x)`?

Допустим, у нас есть уравнение: <code>f(x) = 2x<sup>2</sup> + 3</code>. Что это значит? Как выглядит график этого уравнения? Вот он:

<p align="center">
    <img src="images/fig1.png" width="40%">
</p>

Заметьте: для любого значения `x`, например `2`, если подставить его в уравнение, получится `11`. А что такое `11`? Это *возвращаемое значение* функции `f(x)`, которую мы только что определили.

Другими словами, мы можем интерпретировать входные и выходные значения как точку `(2,11)` на кривой. Для каждого значения `x` мы получаем соответствующее значение `y` — еще одну точку на графике.

Как это связано с FP?

В математике функция всегда принимает входные данные и всегда возвращает результат. В FP часто встречается термин "морфизм" — это просто красивое слово для описания отображения множества значений в другое множество.

В алгебре эти входы и выходы часто интерпретируются как координаты для построения графика. В наших программах мы можем определять функции с самыми разными входами и выходами — но сама идея отображения сохраняется.

### Функция vs Процедура

Зачем вообще говорить о математике и графиках? Потому что функциональное программирование — это искусство использовать функции именно в математическом смысле.

Скорее всего, вы привыкли думать о функциях как о процедурах. В чем разница? Процедура — это произвольный набор операций. У неё могут быть входные параметры, а может и не быть. Может быть результат, а может и не быть.

Функция же всегда принимает входные данные и обязательно всегда возвращает значение.

Если вы хотите писать в стиле FP, **используйте функции как можно чаще** и старайтесь избегать процедур, где это возможно. Все ваши `function` должны принимать входные данные и возвращать результат.

Зачем? Ответ на этот вопрос включает в себя множество слоёв, которые мы будем раскрывать по ходу книги.

## Входные данные функции

Мы уже поняли, что функция должна ожидать входные данные. Давайте разберёмся, как работают входы в функции.

Иногда вы слышите термины "аргументы" и "параметры". В чём разница?

*Аргументы* — это значения, которые вы передаёте при вызове функции, а *параметры* — это именованные переменные внутри функции, которые принимают эти значения. Пример:

```js
function foo(x, y) {
    // ..
}

var a = 3;

foo( a, a * 2 );
```

`a` и `a * 2` (на самом деле, результат `a * 2`, то есть `6`) — это *аргументы* при вызове `foo(..)`. `x` и `y` — это *параметры* внутри функции, которые получают значения `3` и `6` соответственно.

**Примечание:** В JavaScript нет требования, чтобы количество *аргументов* соответствовало количеству *параметров*. Если передать больше аргументов, чем объявлено параметров, лишние будут проигнорированы. Если меньше — необъявленным параметрам будет присвоено значение `undefined`.

### Значения по умолчанию для параметров

Начиная с ES6, параметры могут иметь *значения по умолчанию*. Если аргумент не передан или равен `undefined`, будет использовано значение по умолчанию:

```js
function foo(x = 3) {
    console.log( x );
}

foo();                  // 3
foo( undefined );       // 3
foo( null );            // null
foo( 0 );               // 0
```

Всегда полезно продумать значения по умолчанию для повышения удобства функций. Но учтите: слишком сложные значения по умолчанию могут затруднить чтение и понимание кода.

### Подсчёт входных параметров

Ожидаемое количество аргументов определяется числом объявленных параметров:

```js
function foo(x, y, z) {
    // ..
}
```

`foo(..)` *ожидает* три аргумента, потому что объявлено три параметра. Такое количество называется арностью (arity) функции. Арность `foo(..)` равна 3.

Функцию с одной арностью называют "унарной", с двумя — "бинарной", с тремя и более — "n-арной".

Во время выполнения можно узнать арность функции через свойство `length`:

```js
function foo(x, y, z) {
    // ..
}

foo.length;             // 3
```

Иногда определять арность полезно, если функция может приходить из разных источников и нужно по-разному передавать параметры.

Например:

```js
// fn — ссылка на какую-то функцию
// x — переменная со значением

if (fn.length == 1) {
    fn( x );
}
else if (fn.length == 2) {
    fn( undefined, x );
}
else if (fn.length == 3) {
    fn( undefined, undefined, x );
}
```

**Совет:** Свойство `length` — только для чтения и определяется при объявлении функции. Это метаданные, которые рассказывают о сигнатуре функции, но не гарантируют правильное поведение.

Есть нюансы: некоторые вариации параметров влияют на значение `length`:

```js
function foo(x, y = 2) {
    // ..
}

function bar(x, ...args) {
    // ..
}

function baz( {a, b} ) {
    // ..
}

foo.length;             // 1
bar.length;             // 1
baz.length;             // 1
```

А как узнать, сколько аргументов реально было передано? Раньше это делалось просто через объект `arguments`:

```js
function foo(x, y, z) {
    console.log( arguments.length );
}

foo( 3, 4 );    // 2
```

В ES5+ (и строгом режиме) использование `arguments` считается нежелательным, но для получения количества аргументов — допустимо использовать только `arguments.length`.

Никогда **не используйте** позиционное обращение вроде `arguments[1]` — только `arguments.length`, и только при необходимости.

Но как получить "лишние" аргументы? Прежде чем делать это, спросите себя, действительно ли это нужно — обычно это редкий случай, и, возможно, функцию стоит переписать.

Если всё же нужно, используйте синтаксис ES6 с оператором "rest" (`...`):

```js
function foo(x, y, z, ...args) {
    console.log( x, y, z, args );
}

foo();                  // undefined undefined undefined []
foo( 1, 2, 3 );         // 1 2 3 []
foo( 1, 2, 3, 4 );      // 1 2 3 [4]
foo( 1, 2, 3, 4, 5 );   // 1 2 3 [4, 5]
```

Теперь все "лишние" аргументы собираются в массив `args`, начиная с позиции `0`. Его длина не включает первые три значения.

Можно использовать только `...args`:

```js
function foo(...args) {
    // ..
}
```

Теперь `args` — это массив всех переданных аргументов, и можно безопасно использовать `args[1]`, `args[317]` и т.д.

### Массивы аргументов

Что если нужно передать массив значений как аргументы функции?

```js
function foo(...args) {
    console.log( args[3] );
}

var arr = [ 1, 2, 3, 4, 5 ];

foo( ...arr );                      // 4
```

Оператор `...` может использоваться и при вызове функции, чтобы "раскрыть" массив в отдельные аргументы.

Можно комбинировать разные значения и раскрытия:

```js
var arr = [ 2 ];

foo( 1, ...arr, 3, ...[4,5] );      // 4
```

Запомните: в списке значений (при вызове функции) `...` *раскрывает* массив, а в списке параметров (при объявлении функции) — *собирает* остаток аргументов в массив.

**Совет:** Старые методы `slice(..)`, `concat(..)` и `apply(..)` всё ещё могут быть полезны, но `...` гораздо удобнее и декларативнее.

### Деструктуризация параметров

Возьмём пример с вариативной функцией:

```js
function foo(...args) {
    // ..
}

foo( ...[1,2,3] );
```

Если мы хотим, чтобы функция принимала именно массив, а не отдельные значения, просто уберите оба `...`:

```js
function foo(args) {
    // ..
}

foo( [1,2,3] );
```

А если теперь хочется разложить массив по переменным? Используйте деструктуризацию:

<a name="funcparamdestr"></a>

```js
function foo([x, y, ...args] = []) {
    // ..
}

foo([1,2,3]);
```

`[x, y, ...args]` в параметрах — это деструктуризация массива: первые два значения попадут в `x` и `y`, остальные — в массив `args`.

### Важность декларативного стиля

Вместо деструктуризации, можно было бы сделать так:

```js
function foo(params) {
    var x = params[0];
    var y = params[1];
    var args = params.slice(2);

    // ..
}
```

Но декларативный код (например, с деструктуризацией) лучше коммуницирует намерение, чем императивный (с ручными присваиваниями).

Декларативный код показывает *что* мы хотим получить, а императивный — *как* это сделать. Чем больше мы будем использовать декларативные возможности языка и библиотек, тем проще будет читать код.

## Именованные аргументы

Как и массивы, можно деструктурировать и объектные параметры:

```js
function foo({x, y} = {}) {
    console.log( x, y );
}

foo({
    y: 3
});                    // undefined 3
```

Мы передаём объект, и его поля автоматически попадают в переменные `x` и `y`.

Главное преимущество — для передачи аргументов не важен их порядок, и необязательные параметры можно просто опускать.

В некоторых языках есть явная поддержка именованных аргументов. В JavaScript можно имитировать это, передавая объект.

Такой подход особенно полезен при большом количестве параметров.

**Совет:** Если этот стиль вас заинтересовал, загляните в [приложение C, библиотека FPO](apC.md/#bonus-fpo).

## Возвращаемое значение функции

Теперь перейдём от входов к выходу функции.

В JavaScript функция всегда возвращает значение. Следующие три функции эквивалентны по возвращаемому результату:

```js
function foo() {}

function bar() {
    return;
}

function baz() {
    return undefined;
}
```

Если нет явного `return`, функция возвращает `undefined`.

Но если мы хотим следовать духу FP — пишем функции, а не процедуры — функции всегда должны явно возвращать результат.

В JS функция может вернуть только одно значение. Если нужно вернуть несколько, соберите их в массив или объект:

```js
function foo() {
    var retValue1 = 11;
    var retValue2 = 31;
    return [ retValue1, retValue2 ];
}

var [ x, y ] = foo();
console.log( x + y );           // 42
```

Однако задумайтесь, нельзя ли переписать функцию так, чтобы не возвращать несколько значений, а разделить на более мелкие.

### Ранние возвраты

`return` не только возвращает значение, но и завершает выполнение функции. Пример:

```js
function foo(x) {
    if (x > 10) return x + 1;

    var y = x / 2;

    if (y > 3) {
        if (x % 2 == 0) return x;
    }

    if (y > 1) return y;

    return x;
}
```

Попробуйте угадать, что вернёт `foo(2)`? `foo(4)`? `foo(8)`? `foo(12)`?

**Ответ:** 2, 2, 8, 13.

Такой код сложнее читать, потому что `return` используется и для возврата результата, и для управления потоком.

Более читаемый вариант:

```js
function foo(x) {
    var retValue;

    if (retValue == undefined && x > 10) {
        retValue = x + 1;
    }

    var y = x / 2;

    if (y > 3) {
        if (retValue == undefined && x % 2 == 0) {
            retValue = x;
        }
    }

    if (retValue == undefined && y > 1) {
        retValue = y;
    }

    if (retValue == undefined) {
        retValue = x;
    }

    return retValue;
}
```

Этот вариант длиннее, но его проще читать: в каждом месте мы явно проверяем, что значение ещё не установлено.

Не обязательно всегда писать один `return` на функцию, но стоит быть внимательнее к тому, как используется возврат.

### Неявные возвращаемые значения

Иногда функция возвращает результат не через `return`, а изменяя внешние переменные:

```js
var y;

function f(x) {
    y = (2 * Math.pow( x, 2 )) + 3;
}

f( 2 );

y;                      // 11
```

Лучше так:

```js
function f(x) {
    return (2 * Math.pow( x, 2 )) + 3;
}

var y = f( 2 );
y;                      // 11
```

Изменение внешних переменных — это неявный вывод, а явный `return` делает код прозрачнее.

Более сложный пример — изменение внешних данных (например, массива):

```js
function sum(list) {
    var total = 0;
    for (let i = 0; i < list.length; i++) {
        if (!list[i]) list[i] = 0;

        total = total + list[i];
    }

    return total;
}

var nums = [ 1, 3, 9, 27, , 84 ];

sum( nums );            // 124
```

Теперь в массиве `nums` на месте пустого слота появится `0`. Это называется побочным эффектом функции (side effect). Функция без побочных эффектов — это чистая функция. Мы ещё поговорим о них позже.

## Функции высшего порядка

Функция может принимать и возвращать значения любого типа, в том числе другие функции. Функция, которая принимает или возвращает функцию, называется функцией высшего порядка.

Пример:

```js
function forEach(list, fn) {
    for (let v of list) {
        fn( v );
    }
}

forEach( [1,2,3,4,5], function each(val){
    console.log( val );
} );
// 1 2 3 4 5
```

`forEach(..)` — функция высшего порядка, потому что принимает функцию как аргумент.

Функция высшего порядка может возвращать другую функцию:

```js
function foo() {
    return function inner(msg){
        return msg.toUpperCase();
    };
}

var f = foo();

f( "Hello!" );          // HELLO!
```

Можно передавать функцию через другую функцию:

```js
function foo() {
    return bar( function inner(msg){
        return msg.toUpperCase();
    } );
}

function bar(func) {
    return func( "Hello!" );
}

foo();                  // HELLO!
```

Функции, которые принимают или возвращают функции, — основа FP.

### Работа с областью видимости (closure)

Одна из самых мощных идей — поведение функции, находящейся внутри другой функции. Если внутренняя функция ссылается на переменные внешней, возникает замыкание (closure).

Определение:

> Замыкание — это когда функция запоминает и имеет доступ к переменным из внешнего скоупа, даже если она выполняется вне этого скоупа.

Пример:

```js
function foo(msg) {
    var fn = function inner(){
        return msg.toUpperCase();
    };

    return fn;
}

var helloFn = foo( "Hello!" );

helloFn();              // HELLO!
```

`msg` из области видимости `foo(..)` доступна в `inner`. Даже после завершения `foo(..)`, переменная `msg` не исчезает, пока есть ссылка на внутреннюю функцию.

Ещё примеры замыканий:

```js
function person(name) {
    return function identify(){
        console.log( `I am ${name}` );
    };
}

var fred = person( "Fred" );
var susan = person( "Susan" );

fred();                 // I am Fred
susan();                // I am Susan
```

Замыкание — это не только "заморозка" значения, но и "живое" соединение:

```js
function runningCounter(start) {
    var val = start;

    return function current(increment = 1){
        val = val + increment;
        return val;
    };
}

var score = runningCounter( 0 );

score();                // 1
score();                // 2
score( 13 );            // 15
```

**Внимание:** Такой способ хранения изменяемого состояния через замыкание — то, чего чаще всего стоит избегать в FP. Мы обсудим это подробнее позже.

Если операция требует два входа, один из которых известен заранее, а другой — позже, используйте замыкание:

```js
function makeAdder(x) {
    return function sum(y){
        return x + y;
    };
}

// заранее известны 10 и 37
var addTo10 = makeAdder( 10 );
var addTo37 = makeAdder( 37 );

// позже передаём второй аргумент
addTo10( 3 );           // 13
addTo10( 90 );          // 100

addTo37( 13 );          // 50
```

Этот подход называется частичным применением или каррированием. Подробнее — в [главе 3](ch3.md).

Также можно передавать не только значения, но и функции:

```js
function formatter(formatFn) {
    return function inner(str){
        return formatFn( str );
    };
}

var lower = formatter( function formatting(v){
    return v.toLowerCase();
} );

var upperFirst = formatter( function formatting(v){
    return v[0].toUpperCase() + v.substr( 1 ).toLowerCase();
} );

lower( "WOW" );             // wow
upperFirst( "hello" );      // Hello
```

FP поощряет создание простых функций-обёрток, чтобы их легко было комбинировать.

**Совет:** Заметьте, что `upperFirst(..)` мог бы использовать `lower(..)`.

Замыкания — одна из важнейших практик во всём программировании и фундамент FP. Убедитесь, что вы хорошо их понимаете!

## Синтаксис

Перед тем как двигаться дальше, обсудим синтаксис функций.

В отличие от других разделов книги, здесь больше субъективных мнений и предпочтений. Выбор всегда за вами.

### Имя функции

Объявление функции требует имени:

```js
function helloMyNameIs() {
    // ..
}
```

Функциональные выражения могут быть как именованными, так и анонимными:

```js
foo( function namedFunctionExpr(){
    // ..
} );

bar( function(){    // без имени!
    // ..
} );
```

Анонимные функции обычно отображаются как `(anonymous function)`.

Если вы когда-либо отлаживали программу по stack trace, вы наверняка сталкивались с этим "безымянным" адом. Имена функций помогают понять, что происходит.

С ES6 движок может "догадаться" о желаемом имени функции:

```js
var x = function(){};

x.name;         // x
```

Но не всегда. Например, часто используемые функции-аргументы останутся без имени:

```js
function foo(fn) {
    console.log( fn.name );
}

var x = function(){};

foo( x );               // x
foo( function(){} );    // ""
```

Имена функций полезны не только для отладки, но и для самоссылки (например, для рекурсии или снятия обработчиков событий):

```js
// синхронная рекурсия:
function findPropIn(propName, obj) {
    if (obj == undefined || typeof obj != "object") return;

    if (propName in obj) {
        return obj[propName];
    }
    else {
        for (let prop of Object.keys( obj )) {
            let ret = findPropIn( propName, obj[prop] );
            if (ret !== undefined) {
                return ret;
            }
        }
    }
}
```

```js
// асинхронная рекурсия:
setTimeout( function waitForIt(){
    if (!o.it) {
        setTimeout( waitForIt, 100 );
    }
}, 100 );
```

```js
// отвязка обработчика событий
document.getElementById( "onceBtn" )
    .addEventListener( "click", function handleClick(evt){
        evt.target.removeEventListener( "click", handleClick, false );
        // ..
    }, false );
```

Даже в простых случаях имена делают код более самодокументируемым:

```js
people.map( function getPreferredName(person){
    return person.nicknames[0] || person.firstName;
} )
// ..
```

Анонимные функции часто встречаются в IIFE:

```js
(function(){
    // IIFE!
})();
```

Но гораздо полезнее дать имя:

```js
(function IIFE(){
    // Я — IIFE!
})();
```

**Вывод:** Именованные функции всегда предпочтительнее анонимных. Если не можете придумать имя — возможно, вы не до конца понимаете назначение этой функции.

Я обычно использую имя `TODO` временно — и потом обязательно его замечаю перед коммитом.

Чем тщательнее вы подбираете имена, тем лучше понимаете свой код, и тем выше его качество и поддерживаемость.

### Функции без `function`

Наверняка вы слышали про синтаксис стрелочных функций ES6 (`=>`):

```js
people.map( function getPreferredName(person){
    return person.nicknames[0] || person.firstName;
} );

// или

people.map( person => person.nicknames[0] || person.firstName );
```

Здесь исчезло всё: `function`, `return`, скобки, фигурные скобки, точка с запятой — и имя функции.

Стрелочные функции всегда анонимны; имя можно лишь попытаться вывести из контекста, но чаще всего оно будет отсутствовать.

Если возникнет ошибка, в stack trace отобразится `(anonymous function)`.

Кроме того, синтаксис стрелочных функций довольно разнороден:

```js
people.map( person => person.nicknames[0] || person.firstName );
// несколько параметров — нужны скобки
people.map( (person, idx) => person.nicknames[0] || person.firstName );
// деструктуризация — нужны скобки
people.map( ({ person }) => person.nicknames[0] || person.firstName );
// значение по умолчанию — нужны скобки
people.map( (person = {}) => person.nicknames[0] || person.firstName );
// возвращаем объект — нужны скобки
people.map( person =>
    ({ preferredName: person.nicknames[0] || person.firstName })
);
```

FP-сообщество любит стрелочные функции за лаконичность и сходство с математическим стилем. Это облегчает комбинирование функций.

Я лично предпочитаю именованные функции для читаемости и отладки, но вы вправе решать сами.

**Примечание:** Хотя в продакшене я их почти не использую, для быстрых экспериментов стрелочные функции очень удобны. В этой книге мы тоже будем их использовать.

## Что такое this?

Если вы не знакомы с правилами связывания `this` в JS, рекомендую книгу *You Don't Know JS: this & Object Prototypes*. Здесь мы будем считать, что вы знакомы с этим понятием.

**Замечание:** Мы обсуждаем тему, от которой позже откажемся. Почему? Потому что `this` влияет на другие темы книги, например, на композицию функций.

В JavaScript у функций есть ключевое слово `this`, которое автоматически связывается при вызове. Я предпочитаю рассматривать его как неявный параметр вашей функции.

Пример:

```js
function sum() {
    return this.x + this.y;
}

var context = {
    x: 1,
    y: 2
};

sum.call( context );        // 3

context.sum = sum;
context.sum();              // 3

var s = sum.bind( context );
s();                        // 3
```

Но можно передавать контекст явно:

```js
function sum(ctx) {
    return ctx.x + ctx.y;
}

var context = {
    x: 1,
    y: 2
};

sum( context );
```

Это проще и лучше подходит для FP, облегчая композицию функций.

Прототипное наследование — ещё одна область применения `this`:

```js
var Auth = {
    authorize() {
        var credentials = `${this.username}:${this.password}`;
        this.send( credentials, resp => {
            if (resp.error) this.displayError( resp.error );
            else this.displaySuccess();
        } );
    },
    send(/* .. */) {
        // ..
    }
};

var Login = Object.assign( Object.create( Auth ), {
    doLogin(user, pw) {
        this.username = user;
        this.password = pw;
        this.authorize();
    },
    displayError(err) {
        // ..
    },
    displaySuccess() {
        // ..
    }
} );

Login.doLogin( "fred", "123456" );
```

**Примечание:** `Object.assign(..)` — это ES6+ утилита для поверхностного копирования свойств.

В целом, использование неявных входов через `this` не соответствует принципам FP. Лучше всегда быть явным:

```js
// ..

authorize(ctx) {
    var credentials = `${ctx.username}:${ctx.password}`;
    Auth.send( credentials, function onResp(resp){
        if (resp.error) ctx.displayError( resp.error );
        else ctx.displaySuccess();
    } );
}

// ..

doLogin(user, pw) {
    Auth.authorize( {
        username: user,
        password: pw
    } );
}

// ..
```

Проблема не в организации кода через объекты, а в том, что мы используем неявные входы вместо явных.

## Итоги

Функции — это мощный инструмент.

Но важно понимать, что такое функция: это не просто набор операций, а обязательно — один или несколько входов (желательно один!) и выход.

Функции внутри функций могут иметь замыкания на внешние переменные и "помнить" их. Это важнейшая идея во всём программировании и основа FP.

Осторожнее с анонимными функциями, особенно со стрелочными. Они удобны, но их сложнее читать и отлаживать.

Не используйте функции, зависящие от `this`. Просто не стоит.

Теперь у вас должно быть чёткое и яркое представление о том, что такое *функция* в FP. Пора учиться "запрягать" функции друг с другом и строить более сложные структуры!
