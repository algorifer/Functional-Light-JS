# Functional-Light JavaScript
# Глава 5: Сведение побочных эффектов к минимуму

В [главе 2](ch2.md) мы обсуждали, что функция может иметь выходы помимо значения, возвращаемого через `return`. Сейчас вы уже хорошо понимаете FP-определение функции, поэтому идея таких дополнительных выходов (побочных эффектов) должна быть вам знакома.

В этой главе мы рассмотрим различные формы побочных эффектов и разберём, почему они вредят качеству и читаемости кода.

Но не буду тянуть: суть этой главы — невозможно написать программу полностью без побочных эффектов. Ну, теоретически возможно, но такая программа ничего не будет делать, кроме вычисления значений для самой себя.

FP-программист не устраняет все побочные эффекты. Его цель — ограничить их, насколько это возможно. Для этого сначала нужно хорошо их понимать.

## Побочное действие, пожалуйста

Причина и следствие — одна из самых фундаментальных и интуитивных вещей, которые люди замечают в мире. Толкните книгу со стола — она упадёт. Нам не нужен физик, чтобы это понять.

В программировании мы тоже имеем дело с причинами и следствиями. Вы вызываете функцию (причина) — появляется сообщение на экране (следствие).

Для читаемости кода крайне важно, чтобы читатель ясно видел каждую причину и каждое следствие. Если связь между причиной и следствием неочевидна, читать и понимать программу становится сложнее.

Рассмотрим:

```js
function foo(x) {
    return x * 2;
}

var y = foo( 3 );
```

В этой простой программе сразу видно: вызов `foo` с 3 приводит к результату 6, который присваивается `y`. Нет никакой неясности.

Но теперь:

```js
function foo(x) {
    y = x * 2;
}

var y;

foo( 3 );
```

Результат тот же, но есть большая разница: причина и следствие разорваны. Последствие становится косвенным — это и есть побочный эффект.

**Примечание:** Если функция обращается к переменной вне себя — это называется свободной переменной. Не все такие обращения плохи, но с ними нужно быть очень осторожным.

Что если вам дали воспользоваться функцией `bar(..)`, не показывая её код, но пообещали, что она не имеет побочных эффектов — только возвращает результат?

```js
bar( 4 );           // 42
```

Если вы уверены, что внутри нет побочных эффектов, рассуждать о вызове `bar(..)` гораздо проще. Но если вы не знаете этого — вам придётся разбираться, не изменяет ли она что-то ещё.

**Читаемость функции с побочными эффектами ниже** — чтобы понять программу, приходится читать больше кода.

Более того:

```js
var x = 1;

foo();

console.log( x );

bar();

console.log( x );

baz();

console.log( x );
```

Можете ли вы быть уверены, какие значения выведутся? Правильный ответ — нет. Если вы не знаете, есть ли побочные эффекты у `foo()`, `bar()`, `baz()`, вы не сможете гарантировать значение `x` без полного анализа кода.

То есть, последний `console.log(x)` невозможно предсказать, не "прокрутив" программу в уме.

Кто отлично исполняет ваш код? JS-движок. А вот читатель — не так хорош в этом. Но если вы допускаете побочные эффекты, вы заставляете читателя "эмулировать" выполнение кода.

Если бы `foo()`, `bar()`, `baz()` были без побочных эффектов, они бы не трогали `x`, и нам бы не пришлось их "исполнять в голове" — меньше когнитивной нагрузки.

### Скрытые причины

Побочные эффекты — это не только изменения состояния, но и побочные причины (side causes). Например:

```js
function foo(x) {
    return x + y;
}

var y = 3;

foo( 1 );           // 4
```

`y` не меняется функцией, но теперь результат `foo(..)` зависит от состояния внешней переменной. Если позже:

```js
y = 5;
foo( 1 );           // 6
```

Результат поменяется, и это может удивить.

`foo(..)` теперь зависит от скрытой причины, что портит читаемость. Чтобы улучшить её, все причины для результата функции должны быть явными входными параметрами.

#### Фиксированное состояние

Значит ли это, что функция не должна ссылаться на свободные переменные? Рассмотрим:

```js
function foo(x) {
    return x + bar( x );
}

function bar(x) {
    return x * 2;
}

foo( 3 );           // 9
```

Здесь всё прозрачно: `foo(..)` и `bar(..)` зависят только от `x`. Даже если `bar` — переменная, мы не меняем её значение, и в JS это обычная практика. Это не побочная причина.

Вот ещё пример:

```js
const PI = 3.141592;

function foo(x) {
    return x * PI;
}

foo( 3 );           // 9.424776...
```

**Примечание:** В реальности используйте `Math.PI`!

Здесь `PI` — не побочная причина: функция всегда даст одно и то же при одинаковом входе, и можно заменить все использования `PI` на 3.141592 без изменений программы.

**Главное:** Важно не то, что переменная объявлена через `const`, а то, что её значение не изменяется.

#### Случайность

Случайность — тоже побочная причина. Функция, использующая `Math.random()`, не может предсказать результат по входу. В JS нельзя задать seed, поэтому `Math.random()` — побочная причина.

### Ввод-вывод

Самый частый (и почти неизбежный) побочный эффект — ввод/вывод (I/O). Программа без I/O бессмысленна: она никак не взаимодействует с внешним миром.

В браузере основной ввод — события пользователя, а вывод — DOM. В Node.js — файлы, сеть и т.д.

DOM — и источник, и приёмник данных: мы изменяем его (вывод), читаем из него (ввод).

### Побочные баги

Побочные эффекты могут приводить к багам. Пример:

```js
var users = {};
var userOrders = {};

function fetchUserData(userId) {
    ajax( `http://some.api/user/${userId}`, function onUserData(user){
        users[userId] = user;
    } );
}

function fetchOrders(userId) {
    ajax(
        `http://some.api/orders/${userId}`,
        function onOrders(orders){
            for (let order of orders) {
                users[userId].latestOrder = order;
                userOrders[order.orderId] = order;
            }
        }
    );
}

function deleteOrder(orderId) {
    var user = users[ userOrders[orderId].userId ];
    var isLatestOrder = (userOrders[orderId] == user.latestOrder);

    if (isLatestOrder) {
        hideLatestOrderDisplay();
    }

    ajax(
        `http://some.api/delete/order/${orderId}`,
        function onDelete(success){
            if (success) {
                if (isLatestOrder) {
                    user.latestOrder = null;
                }
                userOrders[orderId] = null;
            }
            else if (isLatestOrder) {
                showLatestOrderDisplay();
            }
        }
    );
}
```

Заметили баг? Если `onOrders(..)` выполнится до `onUserData(..)`, попытка добавить `latestOrder` к несуществующему пользователю вызовет ошибку.

Ещё один баг возможен при определённом порядке вызовов:

```js
fetchUserData( 123 );
onUserData(..);
fetchOrders( 123 );
onOrders(..);

fetchOrders( 123 );
deleteOrder( 456 );
onOrders(..);
onDelete(..);
```

Здесь возможна рассинхронизация данных: например, `latestOrder` может быть сброшен не вовремя, и UI окажется в неконсистентном состоянии.

Все эти сложности — из-за архитектуры на побочных эффектах и изменяемом общем состоянии.

FP-программисты не любят такие баги из-за того, как они затрудняют чтение, анализ, верификацию и доверие к коду. Поэтому они так стараются их ограничить.

Есть разные стратегии борьбы с побочными эффектами — часть рассмотрим уже в этой главе, часть позже. Одно можно сказать точно: **писать без побочных эффектов сложнее, но оно того стоит**.

## Одного раза достаточно

Если всё же приходится изменять состояние, полезно, чтобы операция была идемпотентной. Это значит, что многократное применение такой операции не изменяет состояние после первого раза.

Контрпример (не идемпотентно):

```js
function updateCounter(obj) {
    if (obj.count < 10) {
        obj.count++;
        return true;
    }
    return false;
}
```

Если вызывать многократно — результат будет отличаться, пока `obj.count < 10`.

### Математическая идемпотентность

В математике идемпотентность — это когда операция на своём результате не меняет его: `f(x) == f(f(x))`.

Примеры:

- `Math.abs(..)`
- `Math.min(..)`
- `Math.max(..)`
- `Math.round(..)`
- `Math.floor(..)`
- `Math.ceil(..)`

```js
function toPower0(x) {
    return Math.pow(x, 0);
}

function snapUp3(x) {
    return x - (x % 3) + (x % 3 > 0 && 3);
}

toPower0(3) == toPower0(toPower0(3));         // true
snapUp3(3.14) == snapUp3(snapUp3(3.14));      // true
```

Типовые преобразования в JS тоже идемпотентны:

```js
var x = 42, y = "hello";

String(x) === String(String(x));              // true
Boolean(y) === Boolean(Boolean(y));           // true
```

Ранее мы обсуждали функцию:

```js
identity(3) === identity(identity(3)); // true
```

Некоторые строковые операции тоже идемпотентны:

```js
function upper(x) { return x.toUpperCase(); }
function lower(x) { return x.toLowerCase(); }
upper(str) == upper(upper(str));
lower(str) == lower(lower(str));
```

Можно делать более сложные идемпотентные преобразования:

```js
function currency(val) {
    var num = parseFloat(String(val).replace(/[^\d.-]+/g, ""));
    var sign = (num < 0) ? "-" : "";
    return `${sign}$${Math.abs(num).toFixed(2)}`;
}

currency(-3.1) == currency(currency(-3.1)); // true
```

Где возможно, ограничивайте побочные эффекты идемпотентными операциями.

### Идемпотентность в программировании

В программировании идемпотентность — это когда повторный вызов функции не меняет состояние после первого раза (поведение программы не меняется).

В HTTP, например, PUT считается идемпотентным, а POST — нет.

Примеры:

```js
// идемпотентно:
obj.count = 2;
a[a.length - 1] = 42;
person.name = upper(person.name);

// не идемпотентно:
obj.count++;
a[a.length] = 42;
person.lastUpdated = Date.now();
```

Для DOM:

```js
var hist = document.getElementById("orderHistory");

// идемпотентно:
hist.innerHTML = order.historyText;

// не идемпотентно:
var update = document.createTextNode(order.latestUpdate);
hist.appendChild(update);
```

Не всегда возможно сделать операцию идемпотентной, но если есть выбор — выбирайте её.

## Чистая радость

Функция без побочных причин/эффектов называется чистой. Чистая функция идемпотентна в программном смысле: она не имеет побочных эффектов.

```js
function add(x, y) {
    return x + y;
}
```

Все входы/выходы явные; нет ссылок на внешние переменные.

Однако не все чистые функции идемпотентны в математическом смысле: например, функция, считающая среднее, возвращает не массив, а число, и не может принимать свой результат на вход.

Чистая функция *может* ссылаться на свободные переменные, если они не побочные причины:

```js
const PI = 3.141592;

function circleArea(radius) {
    return PI * radius * radius;
}

function cylinderVolume(radius, height) {
    return height * circleArea(radius);
}
```

Также чистой может быть функция с замыканием:

```js
function unary(fn) {
    return function onlyOneArg(arg){
        return fn(arg);
    };
}
```

Всё чисто, пока `fn` не меняется.

**Примечание:** Если функция при одинаковых входах может возвращать разный результат — она не чистая.

Чистые функции желательны, потому что их вызовы легко анализировать.

**Заметка:** Даже у самой чистой функции есть физические побочные эффекты (нагрев процессора!), но это уже философия.

### Относительная чистота

В JS легко не заметить скрытые побочные эффекты.

Например:

```js
function rememberNumbers(nums) {
    return function caller(fn){
        return fn(nums);
    };
}

var list = [1,2,3,4,5];
var simpleList = rememberNumbers(list);
```

Вроде бы всё чисто, но если изменить массив:

```js
list.push(6);
simpleList(median); // будет другой результат
```

Можно защититься, делая копию массива:

```js
function rememberNumbers(nums) {
    nums = [...nums];
    return function caller(fn){
        return fn(nums);
    };
}
```

Но если функция-аргумент мутирует массив? Например, `reverse()` мутирует исходный массив.

Чтобы защититься, каждый раз делайте копию:

```js
function rememberNumbers(...nums) {
    return function caller(fn){
        return fn([...nums]);
    };
}
```

Но полностью гарантировать чистоту невозможно, если переданная функция — нечистая.

Чистота — это вопрос доверия и контекста. Чем больше чистоты, тем больше уверенности и читаемости.

## Прозрачность (referential transparency)

Третье определение чистоты функции: референциальная прозрачность.

Если функцию можно заменить её результатом без изменения поведения программы — она референциально прозрачна.

```js
function calculateAverage(nums) {
    var sum = 0;
    for (let num of nums) {
        sum += num;
    }
    return sum / nums.length;
}

var numbers = [1,2,4,7,11,16,22];
var avg = calculateAverage(numbers);

console.log("The average is:", avg); // 9
```

Или просто:

```js
var avg = 9;
console.log("The average is:", avg); // 9
```

Для читателя важна возможность мысленно подставить результат вместо вызова функции и не тратить на это больше сил.

### Ментальная прозрачность

Референциальная прозрачность — это не призыв буквально заменять функцию на её результат, а возможность не думать о внутренностях функции, как только вы поняли, что она делает.

Это снижает нагрузку на читающего.

### А если не так прозрачно?

Что если функция имеет побочный эффект, но он нигде не используется? Например:

```js
function calculateAverage(nums) {
    sum = 0;
    for (let num of nums) {
        sum += num;
    }
    return sum / nums.length;
}

var sum;
var numbers = [1,2,4,7,11,16,22];
var avg = calculateAverage(numbers);
```

Здесь функция использует внешнюю переменную, но если никто больше её не трогает — разницы для программы нет.

Аналогия: если дерево падает в лесу, но никто не слышит — был ли звук?

С точки зрения референциальной прозрачности, функция всё ещё считается чистой, но в реальной жизни лучше избегать даже таких побочных эффектов.

#### Побочные эффекты ради производительности

Часто подобные эффекты используются для оптимизации, например, кэширования:

```js
var cache = [];

function specialNumber(n) {
    if (cache[n] !== undefined) {
        return cache[n];
    }
    var x = 1, y = 1;
    for (let i = 1; i <= n; i++) {
        x += i % 2;
        y += i % 3;
    }
    cache[n] = (x * y) / (n + 1);
    return cache[n];
}
```

Пока только эта функция работает с кэшем — референциальная прозрачность сохраняется, но лучше вообще скрыть кэш внутри функции:

```js
var specialNumber = (function memoization(){
    var cache = [];
    return function specialNumber(n){
        if (cache[n] !== undefined) {
            return cache[n];
        }
        var x = 1, y = 1;
        for (let i = 1; i <= n; i++) {
            x += i % 2;
            y += i % 3;
        }
        cache[n] = (x * y) / (n + 1);
        return cache[n];
    };
})();
```

Чем меньше потенциальных побочных эффектов, тем проще и надёжнее код.

## Очистка (purifying)

Лучший вариант — изначально писать чистые функции. Но часто приходится иметь дело с уже существующим кодом.

Если возможно, вынесите побочный эффект из функции наружу:

```js
function addMaxNum(arr) {
    var maxNum = Math.max(...arr);
    arr.push(maxNum + 1);
}

var nums = [4,2,7,3];
addMaxNum(nums);
// nums: [4,2,7,3,8]
```

Сделаем функцию чище:

```js
function addMaxNum(arr) {
    var maxNum = Math.max(...arr);
    return maxNum + 1;
}

nums.push(addMaxNum(nums));
// nums: [4,2,7,3,8]
```

**Примечание:** Можно использовать неизменяемые структуры данных (immutable), подробнее — в следующей главе.

Если рефакторинг сложнее — попробуйте определить, откуда берутся побочные эффекты: свободные переменные, мутация по ссылке, `this` и т.д.

### Инкапсуляция эффектов

Если побочные эффекты связаны со свободными переменными и вы можете менять окружающий код — оберните переменные и функцию в оболочку:

```js
function safer_fetchUserData(userId, users) {
    users = Object.assign({}, users);
    fetchUserData(userId);
    return users;

    function fetchUserData(userId) {
        ajax(
            `http://some.api/user/${userId}`,
            function onUserData(user){
                users[userId] = user;
            }
        );
    }
}
```

**Внимание:** Эта функция всё ещё зависит от побочных эффектов (например, I/O).

Главное — чистота функции достигается на уровне интерфейса, а не всей программы. Но имейте в виду: даже если нечистая функция обёрнута, она всё равно может быть источником багов.

### Маскировка эффектов

Если нельзя изменить функцию, иногда можно создать интерфейс-обёртку, которая:

1. Запоминает состояние
2. Устанавливает начальные значения
3. Вызывает функцию
4. Сохраняет результат
5. Восстанавливает состояние
6. Возвращает результат

```js
function safer_generateMoreRandoms(count, initial) {
    var orig = { nums, smallCount, largeCount };
    nums = [...initial.nums];
    smallCount = initial.smallCount;
    largeCount = initial.largeCount;

    generateMoreRandoms(count);

    var sides = { nums, smallCount, largeCount };
    nums = orig.nums;
    smallCount = orig.smallCount;
    largeCount = orig.largeCount;

    return sides;
}
```

Работает только для синхронного кода!

### Избегание эффектов

Если побочный эффект — это мутация входного значения по ссылке (массив, объект), делайте копию:

```js
function safer_handleInactiveUsers(userList, dateCutoff) {
    let copiedUserList = userList.map(user =>
        Object.assign({}, user)
    );
    handleInactiveUsers(copiedUserList, dateCutoff);
    return copiedUserList;
}
```

Чем глубже копия, тем надёжнее.

### this

Если функция зависит от `this`, используйте явный контекст:

```js
function safer_generate(context) {
    return ids.generate.call(context);
}
```

Это не панацея, но уменьшает влияние побочных эффектов.

## Итог

Побочные эффекты вредят читаемости и качеству кода — они усложняют понимание и приводят к багам.

Чистые функции — основной способ избежать побочных эффектов. Чистая функция всегда возвращает одинаковый результат при одних и тех же входах и не имеет побочных причин/эффектов. Референциальная прозрачность дополнительно повышает доверие к коду.

Лучше всего рефакторить нечистые функции в чистые. Если нельзя — инкапсулируйте побочные эффекты или создайте чистый интерфейс.

Полностью избавиться от побочных эффектов невозможно. Но старайтесь использовать чистые функции везде, где это возможно, и изолируйте нечистые — чтобы их было проще контролировать и тестировать.
